Disassembly Listing for L6203dualmotor
Generated From:
/home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/dist/default/production/L6203dualmotor.X.production.elf
Feb 14, 2019 3:05:47 PM

---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/sh1106.c  --------------------------------
1:                 /* 
2:                  * File:   sh1106.h
3:                  * Author: mjacobs
4:                  *
5:                  * Created on December 14, 2018, 5:27 PM
6:                  */
7:                 
8:                 #include "mcc_generated_files/mcc.h"
9:                 #include  <xc.h>
10:                #include "sh1106.h"
11:                #include "process.h"
12:                
13:                typedef enum {
14:                    I2C_IDLE,
15:                    I2C_SENDADDR,
16:                    I2C_SENDDATA,    
17:                }I2C_STATES;
18:                
19:                typedef struct
20:                {
21:                    uint8_t empty;
22:                    uint8_t full;    
23:                }DATA_QUEUE_STATUS;
24:                
25:                #define MAX_I2C_DATABLOCKS      20
26:                
27:                volatile static I2C_STATES i2cstate = I2C_IDLE;
28:                static uint8_t sh1106_address = 0x78;   // 0x3c << 1 = 0x78
29:                static I2C_DATABLOCK    i2cdatablocks[MAX_I2C_DATABLOCKS];
30:                volatile static I2C_DATABLOCK    *startblock;
31:                volatile static I2C_DATABLOCK    *endblock;
32:                volatile static DATA_QUEUE_STATUS dataqueuestatus;
33:                static uint8_t *pbuffer;
34:                
35:                void i2c_Init(void){    
0007B8  FA0000     LNK #0x0
36:                    
37:                    startblock = i2cdatablocks;
0007BA  2104E0     MOV #0x104E, W0
0007BC  888180     MOV W0, startblock
38:                    endblock = i2cdatablocks;
0007BE  2104E0     MOV #0x104E, W0
0007C0  888190     MOV W0, endblock
39:                    dataqueuestatus.empty = 1;
0007C2  2109E0     MOV #0x109E, W0
0007C4  B3C011     MOV.B #0x1, W1
0007C6  784801     MOV.B W1, [W0]
40:                    dataqueuestatus.full = 0;
0007C8  2109F0     MOV #0x109F, W0
0007CA  EB4080     CLR.B W1
0007CC  784801     MOV.B W1, [W0]
41:                    pbuffer = NULL;
0007CE  EF3034     CLR pbuffer
42:                      
43:                    I2C1BRG = 0x47;     // baud rate set for 400KHz
0007D0  200470     MOV #0x47, W0
0007D2  881020     MOV W0, I2C1BRG
44:                    //I2C1BRG = 0x12A;       // baud rate set for 100Khz  
45:                    I2C1CON = 0x8200;   // enable i2c 7bit addr
0007D4  282000     MOV #0x8200, W0
0007D6  881030     MOV W0, I2C1CON
46:                    I2C1STAT = 0x00; 
0007D8  EF2208     CLR I2C1STAT
47:                
48:                    // clear interrupt flag
49:                    IFS1bits.MI2C1IF = 0;
0007DA  A92802     BCLR IFS1, #1
50:                    // enable i2c interrupt
51:                    IEC1bits.MI2C1IE = 1;    
0007DC  A82822     BSET IEC1, #1
52:                }
0007DE  FA8000     ULNK
0007E0  060000     RETURN
53:                
54:                /*
55:                 * Called on I2C1 Master interrupt flag set  
56:                 */
57:                void __attribute__ ( ( interrupt, no_auto_psv ) ) _MI2C1Interrupt ( void ){ 
000362  F80036     PUSH RCOUNT
000364  BE9F80     MOV.D W0, [W15++]
000366  BE9F82     MOV.D W2, [W15++]
000368  BE9F84     MOV.D W4, [W15++]
00036A  BE9F86     MOV.D W6, [W15++]
00036C  FA0000     LNK #0x0
58:                    
59:                    static uint8_t bytesleft;
60:                    static uint8_t *databuf;     
61:                   
62:                    IFS1bits.MI2C1IF = 0;       // clear interrupt flag  
00036E  A92802     BCLR IFS1, #1
63:                    //IO_RC3_Toggle();
64:                    
65:                    if(I2C1STATbits.IWCOL){        
000370  801041     MOV I2C1STAT, W1
000372  200800     MOV #0x80, W0
000374  608000     AND W1, W0, W0
000376  E00000     CP0 W0
000378  320002     BRA Z, .L3
66:                        I2C1STATbits.IWCOL = 0;
00037A  A9E208     BCLR I2C1STAT, #7
67:                        // write collision occured reset state to IDLE
68:                        i2cstate = I2C_IDLE;        
00037C  EF302E     CLR i2cstate
69:                    }
70:                    
71:                    switch(i2cstate){
00037E  808170     MOV i2cstate, W0
000380  500FE1     SUB W0, #0x1, [W15]
000382  32002A     BRA Z, .L6
000384  500FE1     SUB W0, #0x1, [W15]
000386  390003     BRA NC, .L5
000388  500FE2     SUB W0, #0x2, [W15]
00038A  32002C     BRA Z, .L7
00038C  370045     BRA .L15
72:                        case I2C_IDLE:
73:                            if(dataqueuestatus.empty == 0){
00038E  2109E0     MOV #0x109E, W0
000390  784010     MOV.B [W0], W0
000392  E00400     CP0.B W0
000394  3A0044     BRA NZ, .L16
74:                                // there is data to send
75:                                bytesleft = startblock->length;
000396  808180     MOV startblock, W0
000398  784010     MOV.B [W0], W0
00039A  B7F036     MOV.B WREG, bytesleft
76:                                databuf = startblock->pdata;
00039C  808180     MOV startblock, W0
00039E  900010     MOV [W0+2], W0
0003A0  8881C0     MOV W0, databuf
77:                                pbuffer = startblock->pdata;
0003A2  808180     MOV startblock, W0
0003A4  900010     MOV [W0+2], W0
0003A6  8881A0     MOV W0, pbuffer
78:                                startblock++;
0003A8  808180     MOV startblock, W0
0003AA  400064     ADD W0, #0x4, W0
0003AC  888180     MOV W0, startblock
79:                                if(startblock == (i2cdatablocks + MAX_I2C_DATABLOCKS)){
0003AE  808181     MOV startblock, W1
0003B0  2104E0     MOV #0x104E, W0
0003B2  B00500     ADD #0x50, W0
0003B4  508F80     SUB W1, W0, [W15]
0003B6  3A0002     BRA NZ, .L9
80:                                    startblock = i2cdatablocks;
0003B8  2104E0     MOV #0x104E, W0
0003BA  888180     MOV W0, startblock
81:                                }
82:                                dataqueuestatus.full = 0;
0003BC  2109F0     MOV #0x109F, W0
0003BE  EB4080     CLR.B W1
0003C0  784801     MOV.B W1, [W0]
83:                                if(startblock == endblock){
0003C2  808181     MOV startblock, W1
0003C4  808190     MOV endblock, W0
0003C6  508F80     SUB W1, W0, [W15]
0003C8  3A0003     BRA NZ, .L10
84:                                    dataqueuestatus.empty = 1;
0003CA  2109E0     MOV #0x109E, W0
0003CC  B3C011     MOV.B #0x1, W1
0003CE  784801     MOV.B W1, [W0]
85:                                }
86:                                // send start bit
87:                                I2C1CONbits.SEN = 1;
0003D0  A80206     BSET I2C1CON, #0
88:                                i2cstate = I2C_SENDADDR;
0003D2  200010     MOV #0x1, W0
0003D4  888170     MOV W0, i2cstate
89:                            }            
90:                            break;
0003D6  370024     BRA .L2
00041E  000000     NOP
91:                        case I2C_SENDADDR:
92:                            // send address with r/w bit cleared
93:                            I2C1TRN = sh1106_address;
0003D8  BFD04C     MOV.B 0x104C, WREG
0003DA  FB8000     ZE W0, W0
0003DC  881010     MOV W0, I2C1TRN
94:                            i2cstate = I2C_SENDDATA;
0003DE  200020     MOV #0x2, W0
0003E0  888170     MOV W0, i2cstate
95:                            break;
0003E2  37001E     BRA .L2
96:                        case I2C_SENDDATA:
97:                            if(I2C1STATbits.ACKSTAT){
0003E4  801041     MOV I2C1STAT, W1
0003E6  280000     MOV #0x8000, W0
0003E8  608000     AND W1, W0, W0
0003EA  E00000     CP0 W0
0003EC  320003     BRA Z, .L12
98:                                // no ack from device
99:                                // reset i2c here
100:                               I2C1STATbits.ACKSTAT = 0;
0003EE  A9E209     BCLR 0x209, #7
101:                               i2c_Stop();
0003F0  0701F8     RCALL i2c_Stop
102:                           }
103:                           else{
104:                               if(bytesleft-- == 0){
0003F4  BFD036     MOV.B bytesleft, WREG
0003F6  FB8080     ZE W0, W1
0003F8  E90081     DEC W1, W1
0003FA  DE08CF     LSR W1, #15, W1
0003FC  784081     MOV.B W1, W1
0003FE  E94000     DEC.B W0, W0
000400  B7F036     MOV.B WREG, bytesleft
000402  E00401     CP0.B W1
000404  320002     BRA Z, .L14
105:                                   i2c_Stop();
000406  0701ED     RCALL i2c_Stop
106:                               }
107:                               else{
108:                                   I2C1TRN = *databuf++;
00040A  8081C0     MOV databuf, W0
00040C  784090     MOV.B [W0], W1
00040E  FB8081     ZE W1, W1
000410  881011     MOV W1, I2C1TRN
000412  E80000     INC W0, W0
000414  8881C0     MOV W0, databuf
109:                               }                
110:                           }            
111:                           break;
0003F2  370016     BRA .L2
000408  37000B     BRA .L2
000416  370004     BRA .L2
112:                           
113:                       default:
114:                           // should not get here
115:                           i2c_Stop();
000418  0701E4     RCALL i2c_Stop
116:                           break;                 
00041A  000000     NOP
00041C  370001     BRA .L2
117:                   }    
118:               }
000420  FA8000     ULNK
000422  BE034F     MOV.D [--W15], W6
000424  BE024F     MOV.D [--W15], W4
000426  BE014F     MOV.D [--W15], W2
000428  BE004F     MOV.D [--W15], W0
00042A  F90036     POP RCOUNT
00042C  064000     RETFIE
119:               void i2c_Stop(void){
0007E2  FA0000     LNK #0x0
120:                   // set stop bit 
121:                   I2C1CONbits.PEN = 1;
0007E4  A84206     BSET I2C1CON, #2
122:                   i2cstate = I2C_IDLE;
0007E6  EF302E     CLR i2cstate
123:                   if(pbuffer != NULL){
0007E8  8081A0     MOV pbuffer, W0
0007EA  E00000     CP0 W0
0007EC  320003     BRA Z, .L17
124:                       free(pbuffer);
0007EE  8081A0     MOV pbuffer, W0
0007F0  07FEF9     RCALL _free
125:                       pbuffer = NULL;
0007F2  EF3034     CLR pbuffer
126:                   }
127:                  // __delay_us(2);
128:               }
0007F4  FA8000     ULNK
0007F6  060000     RETURN
129:               
130:               I2C_STATUS_MSG i2c_Write(uint8_t *data, uint8_t length){
0007F8  FA0004     LNK #0x4
0007FA  780F00     MOV W0, [W14]
0007FC  984721     MOV.B W1, [W14+2]
131:                   
132:                   if(dataqueuestatus.full)
0007FE  2109F0     MOV #0x109F, W0
000800  784010     MOV.B [W0], W0
000802  E00400     CP0.B W0
000804  320002     BRA Z, .L20
133:                       return I2C_STATUS_FULL;
000806  200010     MOV #0x1, W0
000808  37001F     BRA .L21
134:                   
135:                   endblock->length = length;
00080A  808190     MOV endblock, W0
00080C  9040AE     MOV.B [W14+2], W1
00080E  784801     MOV.B W1, [W0]
136:                   endblock->pdata = data;
000810  808190     MOV endblock, W0
000812  78009E     MOV [W14], W1
000814  980011     MOV W1, [W0+2]
137:                   endblock++;
000816  808190     MOV endblock, W0
000818  400064     ADD W0, #0x4, W0
00081A  888190     MOV W0, endblock
138:                   if(endblock == (i2cdatablocks + MAX_I2C_DATABLOCKS)){
00081C  808191     MOV endblock, W1
00081E  2104E0     MOV #0x104E, W0
000820  B00500     ADD #0x50, W0
000822  508F80     SUB W1, W0, [W15]
000824  3A0002     BRA NZ, .L22
139:                       endblock = i2cdatablocks;
000826  2104E0     MOV #0x104E, W0
000828  888190     MOV W0, endblock
140:                   }
141:                   dataqueuestatus.empty = 0;
00082A  2109E0     MOV #0x109E, W0
00082C  EB4080     CLR.B W1
00082E  784801     MOV.B W1, [W0]
142:                   if(endblock == startblock){
000830  808191     MOV endblock, W1
000832  808180     MOV startblock, W0
000834  508F80     SUB W1, W0, [W15]
000836  3A0003     BRA NZ, .L23
143:                       dataqueuestatus.full = 1;
000838  2109F0     MOV #0x109F, W0
00083A  B3C011     MOV.B #0x1, W1
00083C  784801     MOV.B W1, [W0]
144:                   }
145:                   if(i2cstate == I2C_IDLE){
00083E  808170     MOV i2cstate, W0
000840  E00000     CP0 W0
000842  3A0001     BRA NZ, .L24
146:                       // force interrupt to start i2c transfer
147:                       IFS1bits.MI2C1IF = 1;
000844  A82802     BSET IFS1, #1
148:                   }
149:                   return I2C_STATUS_OK;
000846  200020     MOV #0x2, W0
150:               }
000848  FA8000     ULNK
00084A  060000     RETURN
151:               
152:               I2C_STATUS_MSG i2c_Ready(void){
00084C  FA0000     LNK #0x0
153:                   if(dataqueuestatus.full)
00084E  2109F0     MOV #0x109F, W0
000850  784010     MOV.B [W0], W0
000852  E00400     CP0.B W0
000854  320002     BRA Z, .L26
154:                       return I2C_STATUS_FULL;
000856  200010     MOV #0x1, W0
000858  37000A     BRA .L27
155:                   if(dataqueuestatus.empty && (i2cstate == I2C_IDLE))
00085A  2109E0     MOV #0x109E, W0
00085C  784010     MOV.B [W0], W0
00085E  E00400     CP0.B W0
000860  320005     BRA Z, .L28
000862  808170     MOV i2cstate, W0
000864  E00000     CP0 W0
000866  3A0002     BRA NZ, .L28
156:                       return I2C_STATUS_IDLE;
000868  EB0000     CLR W0
00086A  370001     BRA .L27
157:                   else return I2C_STATUS_OK;
00086C  200020     MOV #0x2, W0
158:               }
00086E  FA8000     ULNK
000870  060000     RETURN
159:               
160:                void sh1106_Init(void){    
000872  FA0002     LNK #0x2
161:                   
162:                   while(i2c_Ready() != I2C_STATUS_IDLE);
000874  000000     NOP
000876  07FFEA     RCALL i2c_Ready
000878  E00000     CP0 W0
00087A  3AFFFD     BRA NZ, .L30
163:                   uint8_t *pdata;
164:                   if((pdata = (uint8_t *)malloc(6)) == NULL){
00087C  200060     MOV #0x6, W0
00087E  07FE29     RCALL _malloc
000880  780F00     MOV W0, [W14]
000882  78001E     MOV [W14], W0
000884  E00000     CP0 W0
000886  3A0001     BRA NZ, .L31
165:                       // fatal error need to reset
166:                       while(1);
000888  37FFFF     BRA .L32
167:                   }
168:                   *pdata = 0x80;
00088A  78001E     MOV [W14], W0
00088C  B3C801     MOV.B #0x80, W1
00088E  784801     MOV.B W1, [W0]
169:                   *(pdata + 1) = 0xA1;  //segment remap left
000890  E8001E     INC [W14], W0
000892  B3CA11     MOV.B #0xA1, W1
000894  784801     MOV.B W1, [W0]
170:                   *(pdata + 2) = 0x80;
000896  E8801E     INC2 [W14], W0
000898  B3C801     MOV.B #0x80, W1
00089A  784801     MOV.B W1, [W0]
171:                   *(pdata + 3) = 0xC8;  //set scan direction
00089C  78009E     MOV [W14], W1
00089E  408063     ADD W1, #0x3, W0
0008A0  B3CC81     MOV.B #0xC8, W1
0008A2  784801     MOV.B W1, [W0]
172:                   *(pdata + 4) = 0x00;
0008A4  78009E     MOV [W14], W1
0008A6  408064     ADD W1, #0x4, W0
0008A8  EB4080     CLR.B W1
0008AA  784801     MOV.B W1, [W0]
173:                   *(pdata + 5) = 0x50;  //set scan display line
0008AC  78009E     MOV [W14], W1
0008AE  408065     ADD W1, #0x5, W0
0008B0  B3C501     MOV.B #0x50, W1
0008B2  784801     MOV.B W1, [W0]
174:                   // init sh1106
175:                   i2c_Write(pdata, 6);  
0008B4  B3C061     MOV.B #0x6, W1
0008B6  78001E     MOV [W14], W0
0008B8  07FF9F     RCALL i2c_Write
176:               
177:                   sh1106_Clear();
0008BA  070018     RCALL sh1106_Clear
178:                   __delay_ms(100);
0008BC  209850     MOV #0x985, W0
0008BE  2002E1     MOV #0x2E, W1
0008C0  0708E0     RCALL ___delay32, .Letext0, .LFE58
179:                   
180:                   if((pdata = (uint8_t *)malloc(2)) == NULL){
0008C2  200020     MOV #0x2, W0
0008C4  07FE06     RCALL _malloc
0008C6  780F00     MOV W0, [W14]
0008C8  78001E     MOV [W14], W0
0008CA  E00000     CP0 W0
0008CC  3A0001     BRA NZ, .L33
181:                       // fatal error need to reset
182:                       while(1);
0008CE  37FFFF     BRA .L34
183:                   }
184:                   *(pdata + 0) = 0x00;
0008D0  78001E     MOV [W14], W0
0008D2  EB4080     CLR.B W1
0008D4  784801     MOV.B W1, [W0]
185:                   *(pdata + 1) = 0xAF; // turn display on
0008D6  E8001E     INC [W14], W0
0008D8  B3CAF1     MOV.B #0xAF, W1
0008DA  784801     MOV.B W1, [W0]
186:                   i2c_Write(pdata, 2);    
0008DC  B3C021     MOV.B #0x2, W1
0008DE  78001E     MOV [W14], W0
0008E0  07FF8B     RCALL i2c_Write
187:                   __delay_ms(150);   
0008E2  20E480     MOV #0xE48, W0
0008E4  200451     MOV #0x45, W1
0008E6  0708CD     RCALL ___delay32, .Letext0, .LFE58
188:                }
0008E8  FA8000     ULNK
0008EA  060000     RETURN
189:                
190:                void sh1106_Clear(void){
0008EC  FA0006     LNK #0x6
191:                   uint8_t *pdata;
192:                   uint8_t page = 0;
0008EE  EB4000     CLR.B W0
0008F0  784F00     MOV.B W0, [W14]
193:                   
194:                   while (page < 8) {
0008F2  37003C     BRA .L36, .LBE2
00096C  78401E     MOV.B [W14], W0
00096E  504FE7     SUB.B W0, #0x7, [W15]
000970  36FFC1     BRA LEU, .L42, .LBB2
195:                       if ((pdata = (uint8_t *) malloc(140)) == NULL) {
0008F4  2008C0     MOV #0x8C, W0
0008F6  07FDED     RCALL _malloc
0008F8  980720     MOV W0, [W14+4]
0008FA  90002E     MOV [W14+4], W0
0008FC  E00000     CP0 W0
0008FE  3A0001     BRA NZ, .L37
196:                           // fatal error need to reset
197:                           while (1);
000900  37FFFF     BRA .L38
198:                       }
199:                       *(pdata + 0) = 0x80;
000902  90002E     MOV [W14+4], W0
000904  B3C801     MOV.B #0x80, W1
000906  784801     MOV.B W1, [W0]
200:                       *(pdata + 1) = 0xB0 + page; // select page 0
000908  90002E     MOV [W14+4], W0
00090A  E80000     INC W0, W0
00090C  B3CB01     MOV.B #0xB0, W1
00090E  40C09E     ADD.B W1, [W14], W1
000910  784801     MOV.B W1, [W0]
201:                       *(pdata + 2) = 0x80;
000912  90002E     MOV [W14+4], W0
000914  E88000     INC2 W0, W0
000916  B3C801     MOV.B #0x80, W1
000918  784801     MOV.B W1, [W0]
202:                       *(pdata + 3) = 0x00;
00091A  90002E     MOV [W14+4], W0
00091C  400063     ADD W0, #0x3, W0
00091E  EB4080     CLR.B W1
000920  784801     MOV.B W1, [W0]
203:                       *(pdata + 4) = 0x80;
000922  90002E     MOV [W14+4], W0
000924  400064     ADD W0, #0x4, W0
000926  B3C801     MOV.B #0x80, W1
000928  784801     MOV.B W1, [W0]
204:                       *(pdata + 5) = 0x10; // column 0
00092A  90002E     MOV [W14+4], W0
00092C  400065     ADD W0, #0x5, W0
00092E  B3C101     MOV.B #0x10, W1
000930  784801     MOV.B W1, [W0]
205:                       *(pdata + 6) = 0x40;
000932  90002E     MOV [W14+4], W0
000934  400066     ADD W0, #0x6, W0
000936  B3C401     MOV.B #0x40, W1
000938  784801     MOV.B W1, [W0]
206:                       int i = 7;
00093A  200070     MOV #0x7, W0
00093C  980710     MOV W0, [W14+2]
207:                       //139 
208:                       for (; i < 139;) {
00093E  370008     BRA .L39
000950  90009E     MOV [W14+2], W1
000952  2008A0     MOV #0x8A, W0
000954  508F80     SUB W1, W0, [W15]
000956  34FFF4     BRA LE, .L40
209:                           *(pdata + i) = 0x00;
000940  90001E     MOV [W14+2], W0
000942  9000AE     MOV [W14+4], W1
000944  408000     ADD W1, W0, W0
000946  EB4080     CLR.B W1
000948  784801     MOV.B W1, [W0]
210:                           i++;
00094A  90001E     MOV [W14+2], W0
00094C  E80000     INC W0, W0
00094E  980710     MOV W0, [W14+2]
211:                       }        
212:                       while(i2c_Ready() != I2C_STATUS_IDLE);
000958  000000     NOP
00095A  07FF78     RCALL i2c_Ready
00095C  E00000     CP0 W0
00095E  3AFFFD     BRA NZ, .L41
213:                       i2c_Write(pdata, i);
000960  90001E     MOV [W14+2], W0
000962  784000     MOV.B W0, W0
000964  784080     MOV.B W0, W1
000966  90002E     MOV [W14+4], W0
000968  07FF47     RCALL i2c_Write
214:                       page++;        
00096A  E84F1E     INC.B [W14], [W14]
215:                   }  
216:                }
000972  FA8000     ULNK
000974  060000     RETURN
217:                
218:                uint8_t sh1106_blankpix[] = {
219:                    0xc0, 00
220:                };
221:                
222:                const uint8_t colpos[] = {
223:                    0x04, 0x0E, 0x18, 0x22, 0x2C, 0x36, 0x40, 0x4A, 0x54, 0x5E, 0x68, 0x72
224:                };
225:                
226:                const uint8_t linepos[] = {
227:                    0x00, 0x02, 0x04, 0x06     
228:                }; 
229:                
230:                const uint8_t chset1[] = {
231:                    0x00, 0x08, 0x04, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00,
232:                    0x00, 0x40, 0x40, 0x40, 0x40, 0x7F, 0x40, 0x40, 0x40, 0x00,
233:                    0x00, 0x10, 0x08, 0x04, 0x02, 0x02, 0x04, 0x88, 0x70, 0x00,
234:                    0x00, 0x60, 0x50, 0x48, 0x44, 0x42, 0x41, 0x40, 0x40, 0x00,
235:                   
236:                };
237:                
238:                const uint8_t chset2[] = {
239:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //chr 0
240:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
241:                    0x00, 0x08, 0x04, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00, //chr 1
242:                    0x00, 0x40, 0x40, 0x40, 0x40, 0x7F, 0x40, 0x40, 0x40, 0x00,
243:                    0x00, 0x10, 0x08, 0x04, 0x02, 0x02, 0x04, 0x88, 0x70, 0x00, //chr 2
244:                    0x00, 0x60, 0x50, 0x48, 0x44, 0x42, 0x41, 0x40, 0x40, 0x00,
245:                    0x00, 0x04, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0xFE, 0x00, //chr 3
246:                    0x00, 0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3F, 0x00,
247:                    0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, //chr 4
248:                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00,
249:                    0x00, 0x7E, 0x42, 0x42, 0x42, 0x82, 0x02, 0x02, 0x02, 0x00, //chr 5
250:                    0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x21, 0x12, 0x0C, 0x00,
251:                    0x00, 0x80, 0x60, 0x10, 0x88, 0x84, 0x02, 0x02, 0x00, 0x00, //chr 6
252:                    0x00, 0x0E, 0x12, 0x21, 0x40, 0x40, 0x21, 0x12, 0x0C, 0x00,
253:                    0x00, 0x02, 0x02, 0x02, 0x02, 0x82, 0x62, 0x1A, 0x06, 0x00, //chr 7
254:                    0x00, 0x00, 0x60, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00,
255:                    0x00, 0x30, 0x48, 0x84, 0x82, 0x82, 0x84, 0x48, 0x30, 0x00, //chr 8
256:                    0x00, 0x0C, 0x12, 0x21, 0x41, 0x41, 0x21, 0x12, 0x0C, 0x00,
257:                    0x00, 0x30, 0x48, 0x84, 0x02, 0x02, 0x84, 0x48, 0xF0, 0x00, //chr 9
258:                    0x00, 0x00, 0x40, 0x20, 0x11, 0x09, 0x04, 0x02, 0x01, 0x00,
259:                    0x00, 0xF0, 0x08, 0x04, 0x02, 0x02, 0x04, 0x08, 0xF0, 0x00, //chr 10
260:                    0x00, 0x0F, 0x10, 0x20, 0x40, 0x40, 0x20, 0x10, 0x0F, 0x00,
261:                    0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, //chr 11
262:                    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00
263:                };
264:               
265:                
266:                void sh1106_Char(uint8_t col, uint8_t line, int chr) {
000976  FA0010     LNK #0x10
000978  984F40     MOV.B W0, [W14+12]
00097A  984F51     MOV.B W1, [W14+13]
00097C  980772     MOV W2, [W14+14]
267:                   uint8_t *pdata; 
268:                   if((pdata = (uint8_t *)malloc(54)) == NULL){
00097E  200360     MOV #0x36, W0
000980  07FDA8     RCALL _malloc
000982  980730     MOV W0, [W14+6]
000984  90003E     MOV [W14+6], W0
000986  E00000     CP0 W0
000988  3200D1     BRA Z, .L50
269:                       // error just return atm
270:                       return;
000B2C  000000     NOP
271:                   } 
272:                   
273:                   int charindx = chr * 20;
00098A  90007E     MOV [W14+14], W0
00098C  B900F4     MULW.SU W0, #0x14, W0
00098E  780F00     MOV W0, [W14]
274:                   uint8_t page = linepos[line];
000990  90485E     MOV.B [W14+13], W0
000992  FB8000     ZE W0, W0
000994  286961     MOV #0x8696, W1
000996  408000     ADD W1, W0, W0
000998  784090     MOV.B [W0], W1
00099A  984F01     MOV.B W1, [W14+8]
275:                   uint8_t collow = colpos[col] & 0x0F;
00099C  90484E     MOV.B [W14+12], W0
00099E  FB8000     ZE W0, W0
0009A0  2868A1     MOV #0x868A, W1
0009A2  408000     ADD W1, W0, W0
0009A4  784010     MOV.B [W0], W0
0009A6  60406F     AND.B W0, #0xF, W0
0009A8  984F10     MOV.B W0, [W14+9]
276:                   int8_t colhigh = (colpos[col] >> 4) | 0x10;
0009AA  90484E     MOV.B [W14+12], W0
0009AC  FB8000     ZE W0, W0
0009AE  2868A1     MOV #0x868A, W1
0009B0  408000     ADD W1, W0, W0
0009B2  784010     MOV.B [W0], W0
0009B4  FB8000     ZE W0, W0
0009B6  DE0044     LSR W0, #4, W0
0009B8  784000     MOV.B W0, W0
0009BA  A04400     BSET.B W0, #4
0009BC  984F20     MOV.B W0, [W14+10]
277:                   int i = 0;
0009BE  EB0000     CLR W0
0009C0  980710     MOV W0, [W14+2]
278:               
279:                   *(pdata + i) = 0x80;
0009C2  90001E     MOV [W14+2], W0
0009C4  9000BE     MOV [W14+6], W1
0009C6  408000     ADD W1, W0, W0
0009C8  B3C801     MOV.B #0x80, W1
0009CA  784801     MOV.B W1, [W0]
280:                   i++;
0009CC  90001E     MOV [W14+2], W0
0009CE  E80000     INC W0, W0
0009D0  980710     MOV W0, [W14+2]
281:                   *(pdata + i) = 0xB0 + page; //select page 0 - 7
0009D2  90001E     MOV [W14+2], W0
0009D4  9000BE     MOV [W14+6], W1
0009D6  408000     ADD W1, W0, W0
0009D8  90490E     MOV.B [W14+8], W2
0009DA  B3CB01     MOV.B #0xB0, W1
0009DC  414081     ADD.B W2, W1, W1
0009DE  784801     MOV.B W1, [W0]
282:                   i++;
0009E0  90001E     MOV [W14+2], W0
0009E2  E80000     INC W0, W0
0009E4  980710     MOV W0, [W14+2]
283:                   *(pdata + i) = 0x80;
0009E6  90001E     MOV [W14+2], W0
0009E8  9000BE     MOV [W14+6], W1
0009EA  408000     ADD W1, W0, W0
0009EC  B3C801     MOV.B #0x80, W1
0009EE  784801     MOV.B W1, [W0]
284:                   i++;
0009F0  90001E     MOV [W14+2], W0
0009F2  E80000     INC W0, W0
0009F4  980710     MOV W0, [W14+2]
285:                   *(pdata + i) = collow;
0009F6  90001E     MOV [W14+2], W0
0009F8  9000BE     MOV [W14+6], W1
0009FA  408000     ADD W1, W0, W0
0009FC  90489E     MOV.B [W14+9], W1
0009FE  784801     MOV.B W1, [W0]
286:                   i++;
000A00  90001E     MOV [W14+2], W0
000A02  E80000     INC W0, W0
000A04  980710     MOV W0, [W14+2]
287:                   *(pdata + i) = 0x80;
000A06  90001E     MOV [W14+2], W0
000A08  9000BE     MOV [W14+6], W1
000A0A  408000     ADD W1, W0, W0
000A0C  B3C801     MOV.B #0x80, W1
000A0E  784801     MOV.B W1, [W0]
288:                   i++;
000A10  90001E     MOV [W14+2], W0
000A12  E80000     INC W0, W0
000A14  980710     MOV W0, [W14+2]
289:                   *(pdata + i) = colhigh;
000A16  90001E     MOV [W14+2], W0
000A18  9000BE     MOV [W14+6], W1
000A1A  408000     ADD W1, W0, W0
000A1C  9048AE     MOV.B [W14+10], W1
000A1E  784801     MOV.B W1, [W0]
290:                   i++;
000A20  90001E     MOV [W14+2], W0
000A22  E80000     INC W0, W0
000A24  980710     MOV W0, [W14+2]
291:                   int j;
292:                   for (j = 0; j < 10; j++) {
000A26  EB0000     CLR W0
000A28  980720     MOV W0, [W14+4]
000A2A  370016     BRA .L46
000A52  90002E     MOV [W14+4], W0
000A54  E80000     INC W0, W0
000A56  980720     MOV W0, [W14+4]
000A58  90002E     MOV [W14+4], W0
000A5A  500FE9     SUB W0, #0x9, [W15]
000A5C  34FFE7     BRA LE, .L47
293:                       *(pdata + i) = 0xC0;
000A2C  90001E     MOV [W14+2], W0
000A2E  9000BE     MOV [W14+6], W1
000A30  408000     ADD W1, W0, W0
000A32  B3CC01     MOV.B #0xC0, W1
000A34  784801     MOV.B W1, [W0]
294:                       i++;
000A36  90001E     MOV [W14+2], W0
000A38  E80000     INC W0, W0
000A3A  980710     MOV W0, [W14+2]
295:                       *(pdata + i) = chset2[charindx];
000A3C  90001E     MOV [W14+2], W0
000A3E  9000BE     MOV [W14+6], W1
000A40  408000     ADD W1, W0, W0
000A42  286C21     MOV #0x86C2, W1
000A44  40809E     ADD W1, [W14], W1
000A46  784091     MOV.B [W1], W1
000A48  784801     MOV.B W1, [W0]
296:                       i++;
000A4A  90001E     MOV [W14+2], W0
000A4C  E80000     INC W0, W0
000A4E  980710     MOV W0, [W14+2]
297:                       charindx++;
000A50  E80F1E     INC [W14], [W14]
298:                   }
299:               
300:                   *(pdata + i) = 0x80;
000A5E  90001E     MOV [W14+2], W0
000A60  9000BE     MOV [W14+6], W1
000A62  408000     ADD W1, W0, W0
000A64  B3C801     MOV.B #0x80, W1
000A66  784801     MOV.B W1, [W0]
301:                   i++;
000A68  90001E     MOV [W14+2], W0
000A6A  E80000     INC W0, W0
000A6C  980710     MOV W0, [W14+2]
302:                   *(pdata + i) = 0xB0 + page + 1; //select page 0 - 7
000A6E  90001E     MOV [W14+2], W0
000A70  9000BE     MOV [W14+6], W1
000A72  408000     ADD W1, W0, W0
000A74  90490E     MOV.B [W14+8], W2
000A76  B3CB11     MOV.B #0xB1, W1
000A78  414081     ADD.B W2, W1, W1
000A7A  784801     MOV.B W1, [W0]
303:                   i++;
000A7C  90001E     MOV [W14+2], W0
000A7E  E80000     INC W0, W0
000A80  980710     MOV W0, [W14+2]
304:                   *(pdata + i) = 0x80;
000A82  90001E     MOV [W14+2], W0
000A84  9000BE     MOV [W14+6], W1
000A86  408000     ADD W1, W0, W0
000A88  B3C801     MOV.B #0x80, W1
000A8A  784801     MOV.B W1, [W0]
305:                   i++;
000A8C  90001E     MOV [W14+2], W0
000A8E  E80000     INC W0, W0
000A90  980710     MOV W0, [W14+2]
306:                   *(pdata + i) = collow;
000A92  90001E     MOV [W14+2], W0
000A94  9000BE     MOV [W14+6], W1
000A96  408000     ADD W1, W0, W0
000A98  90489E     MOV.B [W14+9], W1
000A9A  784801     MOV.B W1, [W0]
307:                   i++;
000A9C  90001E     MOV [W14+2], W0
000A9E  E80000     INC W0, W0
000AA0  980710     MOV W0, [W14+2]
308:                   *(pdata + i) = 0x80;
000AA2  90001E     MOV [W14+2], W0
000AA4  9000BE     MOV [W14+6], W1
000AA6  408000     ADD W1, W0, W0
000AA8  B3C801     MOV.B #0x80, W1
000AAA  784801     MOV.B W1, [W0]
309:                   i++;
000AAC  90001E     MOV [W14+2], W0
000AAE  E80000     INC W0, W0
000AB0  980710     MOV W0, [W14+2]
310:                   *(pdata + i) = colhigh;
000AB2  90001E     MOV [W14+2], W0
000AB4  9000BE     MOV [W14+6], W1
000AB6  408000     ADD W1, W0, W0
000AB8  9048AE     MOV.B [W14+10], W1
000ABA  784801     MOV.B W1, [W0]
311:                   i++;
000ABC  90001E     MOV [W14+2], W0
000ABE  E80000     INC W0, W0
000AC0  980710     MOV W0, [W14+2]
312:                   for (j = 0; j < 9; j++) {
000AC2  EB0000     CLR W0
000AC4  980720     MOV W0, [W14+4]
000AC6  370016     BRA .L48
000AEE  90002E     MOV [W14+4], W0
000AF0  E80000     INC W0, W0
000AF2  980720     MOV W0, [W14+4]
000AF4  90002E     MOV [W14+4], W0
000AF6  500FE8     SUB W0, #0x8, [W15]
000AF8  34FFE7     BRA LE, .L49
313:                       *(pdata + i) = 0xC0;
000AC8  90001E     MOV [W14+2], W0
000ACA  9000BE     MOV [W14+6], W1
000ACC  408000     ADD W1, W0, W0
000ACE  B3CC01     MOV.B #0xC0, W1
000AD0  784801     MOV.B W1, [W0]
314:                       i++;
000AD2  90001E     MOV [W14+2], W0
000AD4  E80000     INC W0, W0
000AD6  980710     MOV W0, [W14+2]
315:                       *(pdata + i) = chset2[charindx];
000AD8  90001E     MOV [W14+2], W0
000ADA  9000BE     MOV [W14+6], W1
000ADC  408000     ADD W1, W0, W0
000ADE  286C21     MOV #0x86C2, W1
000AE0  40809E     ADD W1, [W14], W1
000AE2  784091     MOV.B [W1], W1
000AE4  784801     MOV.B W1, [W0]
316:                       i++;
000AE6  90001E     MOV [W14+2], W0
000AE8  E80000     INC W0, W0
000AEA  980710     MOV W0, [W14+2]
317:                       charindx++;
000AEC  E80F1E     INC [W14], [W14]
318:                   }
319:                   *(pdata + i) = 0x40;
000AFA  90001E     MOV [W14+2], W0
000AFC  9000BE     MOV [W14+6], W1
000AFE  408000     ADD W1, W0, W0
000B00  B3C401     MOV.B #0x40, W1
000B02  784801     MOV.B W1, [W0]
320:                   i++;
000B04  90001E     MOV [W14+2], W0
000B06  E80000     INC W0, W0
000B08  980710     MOV W0, [W14+2]
321:                   *(pdata + i) = chset2[charindx];
000B0A  90001E     MOV [W14+2], W0
000B0C  9000BE     MOV [W14+6], W1
000B0E  408000     ADD W1, W0, W0
000B10  286C21     MOV #0x86C2, W1
000B12  40809E     ADD W1, [W14], W1
000B14  784091     MOV.B [W1], W1
000B16  784801     MOV.B W1, [W0]
322:                   i++;
000B18  90001E     MOV [W14+2], W0
000B1A  E80000     INC W0, W0
000B1C  980710     MOV W0, [W14+2]
323:                   charindx++;    
000B1E  E80F1E     INC [W14], [W14]
324:                   
325:                   //while(i2c_Ready() != I2C_STATUS_IDLE);
326:                  
327:                   i2c_Write(pdata, i);
000B20  90001E     MOV [W14+2], W0
000B22  784000     MOV.B W0, W0
000B24  784080     MOV.B W0, W1
000B26  90003E     MOV [W14+6], W0
000B28  07FE67     RCALL i2c_Write
000B2A  370001     BRA .L43
328:                  
329:                }
000B2E  FA8000     ULNK
000B30  060000     RETURN
330:                
331:                void display_Value(int16_t val){
000B32  FA0006     LNK #0x6
000B34  980720     MOV W0, [W14+4]
332:                    bool negf;
333:                    uint8_t pos= 6;
000B36  B3C060     MOV.B #0x6, W0
000B38  984710     MOV.B W0, [W14+1]
334:                    
335:                    if(val < 0){
000B3A  90002E     MOV [W14+4], W0
000B3C  E00000     CP0 W0
000B3E  3D0006     BRA GE, .L52
336:                        negf = true;
000B40  B3C010     MOV.B #0x1, W0
000B42  784F00     MOV.B W0, [W14]
337:                        val = (~val + 1);
000B44  90002E     MOV [W14+4], W0
000B46  EA0000     NEG W0, W0
000B48  980720     MOV W0, [W14+4]
000B4A  370002     BRA .L53
338:                    }
339:                    else{
340:                        negf = false;
000B4C  EB4000     CLR.B W0
000B4E  784F00     MOV.B W0, [W14]
341:                    }
342:                    if(val == 0){
000B50  90002E     MOV [W14+4], W0
000B52  E00000     CP0 W0
000B54  3A0033     BRA NZ, .L56
343:                        sh1106_Char(1, 1, 0);
000B56  EB0100     CLR W2
000B58  B3C011     MOV.B #0x1, W1
000B5A  B3C010     MOV.B #0x1, W0
000B5C  07FF0C     RCALL sh1106_Char
344:                        sh1106_Char(2, 1, 0);
000B5E  EB0100     CLR W2
000B60  B3C011     MOV.B #0x1, W1
000B62  B3C020     MOV.B #0x2, W0
000B64  07FF08     RCALL sh1106_Char
345:                        sh1106_Char(3, 1, 0);
000B66  EB0100     CLR W2
000B68  B3C011     MOV.B #0x1, W1
000B6A  B3C030     MOV.B #0x3, W0
000B6C  07FF04     RCALL sh1106_Char
346:                        sh1106_Char(4, 1, 0);
000B6E  EB0100     CLR W2
000B70  B3C011     MOV.B #0x1, W1
000B72  B3C040     MOV.B #0x4, W0
000B74  07FF00     RCALL sh1106_Char
347:                        sh1106_Char(5, 1, 0);
000B76  EB0100     CLR W2
000B78  B3C011     MOV.B #0x1, W1
000B7A  B3C050     MOV.B #0x5, W0
000B7C  07FEFC     RCALL sh1106_Char
348:                        sh1106_Char(6, 1, 10);         
000B7E  2000A2     MOV #0xA, W2
000B80  B3C011     MOV.B #0x1, W1
000B82  B3C060     MOV.B #0x6, W0
000B84  07FEF8     RCALL sh1106_Char
349:                        return;
000B86  370032     BRA .L51
350:                    }  
351:                    int dig;
352:                    while(val != 0){
000BBC  90002E     MOV [W14+4], W0
000BBE  E00000     CP0 W0
000BC0  3AFFE3     BRA NZ, .L58
353:                    
354:                       dig = val % 10;
000B88  9000AE     MOV [W14+4], W1
000B8A  2000A0     MOV #0xA, W0
000B8C  780100     MOV W0, W2
000B8E  090011     REPEAT #0x11
000B90  D80082     DIV.SW W1, W2
000B92  FD0080     EXCH W0, W1
000B94  980710     MOV W0, [W14+2]
355:                       if(dig == 0)
000B96  90001E     MOV [W14+2], W0
000B98  E00000     CP0 W0
000B9A  3A0002     BRA NZ, .L57
356:                           dig = 10;
000B9C  2000A0     MOV #0xA, W0
000B9E  980710     MOV W0, [W14+2]
357:                       sh1106_Char(pos, 1, dig);
000BA0  90011E     MOV [W14+2], W2
000BA2  B3C011     MOV.B #0x1, W1
000BA4  90401E     MOV.B [W14+1], W0
000BA6  07FEE7     RCALL sh1106_Char
358:                        
359:                       val = val / 10;
000BA8  90012E     MOV [W14+4], W2
000BAA  266670     MOV #0x6667, W0
000BAC  B99000     MUL.SS W2, W0, W0
000BAE  DE88C2     ASR W1, #2, W1
000BB0  DE904F     ASR W2, #15, W0
000BB2  508000     SUB W1, W0, W0
000BB4  980720     MOV W0, [W14+4]
360:                       pos--;           
000BB6  90401E     MOV.B [W14+1], W0
000BB8  E94000     DEC.B W0, W0
000BBA  984710     MOV.B W0, [W14+1]
361:                        
362:                    } 
363:                    if(negf == true){
000BC2  78401E     MOV.B [W14], W0
000BC4  E00400     CP0.B W0
000BC6  32000F     BRA Z, .L60
364:                        sh1106_Char(pos, 1, 11);
000BC8  2000B2     MOV #0xB, W2
000BCA  B3C011     MOV.B #0x1, W1
000BCC  90401E     MOV.B [W14+1], W0
000BCE  07FED3     RCALL sh1106_Char
365:                        pos--;
000BD0  90401E     MOV.B [W14+1], W0
000BD2  E94000     DEC.B W0, W0
000BD4  984710     MOV.B W0, [W14+1]
366:                    }     
367:                    for(; pos > 0 ; pos--){
000BD6  370007     BRA .L60
000BE0  90401E     MOV.B [W14+1], W0
000BE2  E94000     DEC.B W0, W0
000BE4  984710     MOV.B W0, [W14+1]
000BE6  90401E     MOV.B [W14+1], W0
000BE8  E00400     CP0.B W0
000BEA  3AFFF6     BRA NZ, .L61
368:                        sh1106_Char(pos, 1, 0);
000BD8  EB0100     CLR W2
000BDA  B3C011     MOV.B #0x1, W1
000BDC  90401E     MOV.B [W14+1], W0
000BDE  07FECB     RCALL sh1106_Char
369:                    }          
370:                }
000BEC  FA8000     ULNK
000BEE  060000     RETURN
371:                
372:                void display_Line3(int16_t val){
000BF0  FA0006     LNK #0x6
000BF2  980720     MOV W0, [W14+4]
373:                    bool negf;
374:                    uint8_t pos= 6;
000BF4  B3C060     MOV.B #0x6, W0
000BF6  984710     MOV.B W0, [W14+1]
375:                    
376:                    if(val < 0){
000BF8  90002E     MOV [W14+4], W0
000BFA  E00000     CP0 W0
000BFC  3D0006     BRA GE, .L63
377:                        negf = true;
000BFE  B3C010     MOV.B #0x1, W0
000C00  784F00     MOV.B W0, [W14]
378:                        val = (~val + 1);
000C02  90002E     MOV [W14+4], W0
000C04  EA0000     NEG W0, W0
000C06  980720     MOV W0, [W14+4]
000C08  370002     BRA .L64
379:                    }
380:                    else{
381:                        negf = false;
000C0A  EB4000     CLR.B W0
000C0C  784F00     MOV.B W0, [W14]
382:                    }
383:                    
384:                    if(val == 0){
000C0E  90002E     MOV [W14+4], W0
000C10  E00000     CP0 W0
000C12  3A0036     BRA NZ, .L67
385:                        sh1106_Char(1, 4, 0);
000C14  EB0100     CLR W2
000C16  B3C041     MOV.B #0x4, W1
000C18  B3C010     MOV.B #0x1, W0
000C1A  07FEAD     RCALL sh1106_Char
386:                        sh1106_Char(2, 4, 0);
000C1C  EB0100     CLR W2
000C1E  B3C041     MOV.B #0x4, W1
000C20  B3C020     MOV.B #0x2, W0
000C22  07FEA9     RCALL sh1106_Char
387:                        sh1106_Char(3, 4, 0);
000C24  EB0100     CLR W2
000C26  B3C041     MOV.B #0x4, W1
000C28  B3C030     MOV.B #0x3, W0
000C2A  07FEA5     RCALL sh1106_Char
388:                        sh1106_Char(4, 4, 0);
000C2C  EB0100     CLR W2
000C2E  B3C041     MOV.B #0x4, W1
000C30  B3C040     MOV.B #0x4, W0
000C32  07FEA1     RCALL sh1106_Char
389:                        sh1106_Char(5, 4, 0);
000C34  EB0100     CLR W2
000C36  B3C041     MOV.B #0x4, W1
000C38  B3C050     MOV.B #0x5, W0
000C3A  07FE9D     RCALL sh1106_Char
390:                        sh1106_Char(6, 4, 10);         
000C3C  2000A2     MOV #0xA, W2
000C3E  B3C041     MOV.B #0x4, W1
000C40  B3C060     MOV.B #0x6, W0
000C42  07FE99     RCALL sh1106_Char
391:                        return;
000C44  370035     BRA .L62
392:                    }     
393:                  
394:                    int dig;
395:                    
396:                    while(val != 0){
000C80  90002E     MOV [W14+4], W0
000C82  E00000     CP0 W0
000C84  3AFFE0     BRA NZ, .L69
397:                    
398:                       dig = val % 10;
000C46  90002E     MOV [W14+4], W0
000C48  266671     MOV #0x6667, W1
000C4A  B98101     MUL.SS W0, W1, W2
000C4C  DE9942     ASR W3, #2, W2
000C4E  DE80CF     ASR W0, #15, W1
000C50  510081     SUB W2, W1, W1
000C52  B909EA     MULW.SU W1, #0xA, W2
000C54  780082     MOV W2, W1
000C56  500001     SUB W0, W1, W0
000C58  980710     MOV W0, [W14+2]
399:                       if(dig == 0)
000C5A  90001E     MOV [W14+2], W0
000C5C  E00000     CP0 W0
000C5E  3A0002     BRA NZ, .L68
400:                           dig = 10;
000C60  2000A0     MOV #0xA, W0
000C62  980710     MOV W0, [W14+2]
401:                       sh1106_Char(pos, 4, dig);
000C64  90011E     MOV [W14+2], W2
000C66  B3C041     MOV.B #0x4, W1
000C68  90401E     MOV.B [W14+1], W0
000C6A  07FE85     RCALL sh1106_Char
402:                        
403:                       val = val / 10;
000C6C  90012E     MOV [W14+4], W2
000C6E  266670     MOV #0x6667, W0
000C70  B99000     MUL.SS W2, W0, W0
000C72  DE88C2     ASR W1, #2, W1
000C74  DE904F     ASR W2, #15, W0
000C76  508000     SUB W1, W0, W0
000C78  980720     MOV W0, [W14+4]
404:                       pos--;
000C7A  90401E     MOV.B [W14+1], W0
000C7C  E94000     DEC.B W0, W0
000C7E  984710     MOV.B W0, [W14+1]
405:                    }         
406:                    
407:                    if(negf == true){
000C86  78401E     MOV.B [W14], W0
000C88  E00400     CP0.B W0
000C8A  32000F     BRA Z, .L71
408:                        sh1106_Char(pos, 4, 11);
000C8C  2000B2     MOV #0xB, W2
000C8E  B3C041     MOV.B #0x4, W1
000C90  90401E     MOV.B [W14+1], W0
000C92  07FE71     RCALL sh1106_Char
409:                        pos--;
000C94  90401E     MOV.B [W14+1], W0
000C96  E94000     DEC.B W0, W0
000C98  984710     MOV.B W0, [W14+1]
410:                    }
411:                    
412:                    for(; pos > 0 ; pos--){
000C9A  370007     BRA .L71
000CA4  90401E     MOV.B [W14+1], W0
000CA6  E94000     DEC.B W0, W0
000CA8  984710     MOV.B W0, [W14+1]
000CAA  90401E     MOV.B [W14+1], W0
000CAC  E00400     CP0.B W0
000CAE  3AFFF6     BRA NZ, .L72
413:                        sh1106_Char(pos, 4, 0);
000C9C  EB0100     CLR W2
000C9E  B3C041     MOV.B #0x4, W1
000CA0  90401E     MOV.B [W14+1], W0
000CA2  07FE69     RCALL sh1106_Char
414:                    }
415:                }
000CB0  FA8000     ULNK
000CB2  060000     RETURN
416:                 
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/servo.c  ---------------------------------
1:                 /* 
2:                  * File:   servo.h
3:                  * Author: mjacobs
4:                  *
5:                  * Created on February 11, 2019, 2:08 PM
6:                  */
7:                 
8:                 #include "process.h"
9:                 #include "servo.h"
10:                #include "motor.h"
11:                #include <stdlib.h>
12:                #include "mcc_generated_files/mcc.h"
13:                
14:                const uint16_t SERVOTIME = 100;
15:                const int16_t isumMax = 400;
16:                const int16_t isumMin = -400;
17:                
18:                static uint16_t servo1trigger = 0;
19:                static uint16_t servo2trigger = 0;
20:                
21:                static PID_TEMRS pid1;
22:                
23:                static int16_t pressure1setvalue;
24:                
25:                
26:                void servo_Init(void) {
001014  FA0000     LNK #0x0
27:                    pid1.Kp = 16;
001016  200100     MOV #0x10, W0
001018  888780     MOV W0, pid1
28:                    pid1.Ki = 4;
00101A  200040     MOV #0x4, W0
00101C  888790     MOV W0, 0x10F2
29:                    pid1.Kd = 4;
00101E  200040     MOV #0x4, W0
001020  8887A0     MOV W0, 0x10F4
30:                    pid1.i = 0;
001022  B80060     MUL.UU W0, #0x0, W0
001024  8887B0     MOV W0, 0x10F6
001026  8887C1     MOV W1, 0x10F8
31:                    pid1.d = 0;
001028  B80060     MUL.UU W0, #0x0, W0
00102A  8887D0     MOV W0, 0x10FA
00102C  8887E1     MOV W1, 0x10FC
32:                    
33:                }
00102E  FA8000     ULNK
001030  060000     RETURN
34:                
35:                void servo_Trigger(SERVO_MODE m){
001032  FA0002     LNK #0x2
001034  780F00     MOV W0, [W14]
36:                    
37:                    if(m == SERVO1 || m == SERVOBOTH){
001036  78001E     MOV [W14], W0
001038  E00000     CP0 W0
00103A  320003     BRA Z, .L3
00103C  78001E     MOV [W14], W0
00103E  500FE2     SUB W0, #0x2, [W15]
001040  3A0010     BRA NZ, .L4
38:                        servo1trigger = SERVOTIME; 
001042  843D90     MOV 0x87B2, W0
001044  8881D0     MOV W0, servo1trigger
39:                        pid1.i = 0;
001046  B80060     MUL.UU W0, #0x0, W0
001048  8887B0     MOV W0, 0x10F6
00104A  8887C1     MOV W1, 0x10F8
40:                        pid1.d = 0;
00104C  B80060     MUL.UU W0, #0x0, W0
00104E  8887D0     MOV W0, 0x10FA
001050  8887E1     MOV W1, 0x10FC
41:                        pressure1setvalue = getSetPressure(PRES1);
001052  EB0000     CLR W0
001054  070181     RCALL getSetPressure
001056  8881F0     MOV W0, pressure1setvalue
42:                        motor1_On();
001058  07FF5A     RCALL motor1_On
43:                        motor1_Move(500, MOTOR_DOWNMOTION);
00105A  200021     MOV #0x2, W1
00105C  201F40     MOV #0x1F4, W0
00105E  07FF9C     RCALL motor1_Move
44:                        display_Off();
001060  07010C     RCALL display_Off
45:                    }
46:                    if(m == SERVO2 || m == SERVOBOTH){
001062  78001E     MOV [W14], W0
001064  500FE1     SUB W0, #0x1, [W15]
001066  320003     BRA Z, .L5
001068  78001E     MOV [W14], W0
00106A  500FE2     SUB W0, #0x2, [W15]
00106C  3A0002     BRA NZ, .L2
47:                        servo2trigger = SERVOTIME;
00106E  843D90     MOV 0x87B2, W0
001070  8881E0     MOV W0, servo2trigger
48:                    }        
49:                }
001072  FA8000     ULNK
001074  060000     RETURN
50:                
51:                void servo_1Run(int16_t p){
001076  FA0010     LNK #0x10
001078  781F88     MOV W8, [W15++]
00107A  980770     MOV W0, [W14+14]
52:                    if(servo1trigger == 0)
00107C  8081D0     MOV servo1trigger, W0
00107E  E00000     CP0 W0
001080  3200B0     BRA Z, .L17
53:                        return;
0011E2  000000     NOP
0011E4  370001     BRA .L7
54:                     IO_RC3_Toggle();
001082  807120     MOV LATC, W0
001084  DE0043     LSR W0, #3, W0
001086  604061     AND.B W0, #0x1, W0
001088  A20400     BTG.B W0, #0
00108A  604061     AND.B W0, #0x1, W0
00108C  FB8000     ZE W0, W0
00108E  600061     AND W0, #0x1, W0
001090  DD0043     SL W0, #3, W0
001092  807121     MOV LATC, W1
001094  A13001     BCLR W1, #3
001096  700001     IOR W0, W1, W0
001098  887120     MOV W0, LATC
55:                    int32_t error = pressure1setvalue - p;
00109A  8081F1     MOV pressure1setvalue, W1
00109C  90007E     MOV [W14+14], W0
00109E  508000     SUB W1, W0, W0
0010A0  DE80CF     ASR W0, #15, W1
0010A2  980730     MOV W0, [W14+6]
0010A4  980741     MOV W1, [W14+8]
56:                    
57:                    pid1.i = error + pid1.i;
0010A6  8087B2     MOV 0x10F6, W2
0010A8  8087C3     MOV 0x10F8, W3
0010AA  90003E     MOV [W14+6], W0
0010AC  9000CE     MOV [W14+8], W1
0010AE  400002     ADD W0, W2, W0
0010B0  488083     ADDC W1, W3, W1
0010B2  8887B0     MOV W0, 0x10F6
0010B4  8887C1     MOV W1, 0x10F8
58:                    if(pid1.i > isumMax)
0010B6  8087B2     MOV 0x10F6, W2
0010B8  8087C3     MOV 0x10F8, W3
0010BA  843DA0     MOV 0x87B4, W0
0010BC  DE80CF     ASR W0, #15, W1
0010BE  510F80     SUB W2, W0, [W15]
0010C0  598F81     SUBB W3, W1, [W15]
0010C2  360005     BRA LEU, .L10
59:                        pid1.i = isumMax;
0010C4  843DA0     MOV 0x87B4, W0
0010C6  DE80CF     ASR W0, #15, W1
0010C8  8887B0     MOV W0, 0x10F6
0010CA  8887C1     MOV W1, 0x10F8
0010CC  37000B     BRA .L11
60:                    else if(pid1.i < isumMin)
0010CE  8087B2     MOV 0x10F6, W2
0010D0  8087C3     MOV 0x10F8, W3
0010D2  843DB0     MOV 0x87B6, W0
0010D4  DE80CF     ASR W0, #15, W1
0010D6  510F80     SUB W2, W0, [W15]
0010D8  598F81     SUBB W3, W1, [W15]
0010DA  310004     BRA C, .L11
61:                        pid1.i = isumMin;
0010DC  843DB0     MOV 0x87B6, W0
0010DE  DE80CF     ASR W0, #15, W1
0010E0  8887B0     MOV W0, 0x10F6
0010E2  8887C1     MOV W1, 0x10F8
62:                    
63:                    int32_t derror = error - pid1.d;
0010E4  90013E     MOV [W14+6], W2
0010E6  9001CE     MOV [W14+8], W3
0010E8  8087D0     MOV 0x10FA, W0
0010EA  8087E1     MOV 0x10FC, W1
0010EC  510000     SUB W2, W0, W0
0010EE  598081     SUBB W3, W1, W1
0010F0  980750     MOV W0, [W14+10]
0010F2  980761     MOV W1, [W14+12]
64:                    pid1.d = error;
0010F4  90003E     MOV [W14+6], W0
0010F6  9000CE     MOV [W14+8], W1
0010F8  8887D0     MOV W0, 0x10FA
0010FA  8887E1     MOV W1, 0x10FC
65:                    
66:                    if((error < 2) && (error > -2)){
0010FC  90013E     MOV [W14+6], W2
0010FE  9001CE     MOV [W14+8], W3
001100  200010     MOV #0x1, W0
001102  200001     MOV #0x0, W1
001104  510F80     SUB W2, W0, [W15]
001106  598F81     SUBB W3, W1, [W15]
001108  3C0010     BRA GT, .L12
00110A  90013E     MOV [W14+6], W2
00110C  9001CE     MOV [W14+8], W3
00110E  EB8000     SETM W0
001110  EB8080     SETM W1
001112  510F80     SUB W2, W0, [W15]
001114  598F81     SUBB W3, W1, [W15]
001116  350009     BRA LT, .L12
67:                        servo1trigger--;
001118  8081D0     MOV servo1trigger, W0
00111A  E90000     DEC W0, W0
00111C  8881D0     MOV W0, servo1trigger
68:                        if(servo1trigger == 0){
00111E  8081D0     MOV servo1trigger, W0
001120  E00000     CP0 W0
001122  3A0061     BRA NZ, .L18
69:                            motor1_Hold();
001124  07FEDB     RCALL motor1_Hold
70:                            display_On();
001126  0700A4     RCALL display_On
71:                        }
72:                        return;
001128  37005F     BRA .L7
0011E6  000000     NOP
73:                    }
74:                    
75:                    
76:                    int32_t output = (error * pid1.Kp) + (pid1.i * pid1.Ki) + (derror * pid1.Kd);
00112A  808780     MOV pid1, W0
00112C  EB0080     CLR W1
00112E  90013E     MOV [W14+6], W2
001130  B99181     MULW.SS W2, W1, W2
001132  9001CE     MOV [W14+8], W3
001134  B99A80     MULW.SS W3, W0, W4
001136  780184     MOV W4, W3
001138  410103     ADD W2, W3, W2
00113A  9001BE     MOV [W14+6], W3
00113C  B81800     MUL.UU W3, W0, W0
00113E  410101     ADD W2, W1, W2
001140  780082     MOV W2, W1
001142  BE0300     MOV.D W0, W6
001144  8087B2     MOV 0x10F6, W2
001146  8087C3     MOV 0x10F8, W3
001148  808790     MOV 0x10F2, W0
00114A  EB0080     CLR W1
00114C  B99A80     MULW.SS W3, W0, W4
00114E  B98C82     MULW.SS W1, W2, W8
001150  780288     MOV W8, W5
001152  420205     ADD W4, W5, W4
001154  B81000     MUL.UU W2, W0, W0
001156  420201     ADD W4, W1, W4
001158  780084     MOV W4, W1
00115A  400206     ADD W0, W6, W4
00115C  488287     ADDC W1, W7, W5
00115E  8087A0     MOV 0x10F4, W0
001160  EB0080     CLR W1
001162  90015E     MOV [W14+10], W2
001164  B99181     MULW.SS W2, W1, W2
001166  9001EE     MOV [W14+12], W3
001168  B99B80     MULW.SS W3, W0, W6
00116A  780186     MOV W6, W3
00116C  410103     ADD W2, W3, W2
00116E  9001DE     MOV [W14+10], W3
001170  B81800     MUL.UU W3, W0, W0
001172  410101     ADD W2, W1, W2
001174  780082     MOV W2, W1
001176  400004     ADD W0, W4, W0
001178  488085     ADDC W1, W5, W1
00117A  BE8F00     MOV.D W0, [W14]
77:                    
78:                    MOTOR_MOTION m = MOTOR_DOWNMOTION;
00117C  200020     MOV #0x2, W0
00117E  980720     MOV W0, [W14+4]
79:                    
80:                    if(output < 0){
001180  78001E     MOV [W14], W0
001182  90009E     MOV [W14+2], W1
001184  500FE0     SUB W0, #0x0, [W15]
001186  588FE0     SUBB W1, #0x0, [W15]
001188  3D0007     BRA GE, .L14
81:                        m = MOTOR_UPMOTION;
00118A  200010     MOV #0x1, W0
00118C  980720     MOV W0, [W14+4]
82:                        output = abs(output);
00118E  78001E     MOV [W14], W0
001190  A7F000     BTSC W0, #15
001192  EA0000     NEG W0, W0
001194  DE80CF     ASR W0, #15, W1
001196  BE8F00     MOV.D W0, [W14]
83:                    }
84:                    
85:                    if(output < 400)
001198  2018F0     MOV #0x18F, W0
00119A  200001     MOV #0x0, W1
00119C  78011E     MOV [W14], W2
00119E  90019E     MOV [W14+2], W3
0011A0  510F80     SUB W2, W0, [W15]
0011A2  598F81     SUBB W3, W1, [W15]
0011A4  3C0004     BRA GT, .L15
86:                        output = 400;
0011A6  201900     MOV #0x190, W0
0011A8  200001     MOV #0x0, W1
0011AA  BE8F00     MOV.D W0, [W14]
0011AC  37000A     BRA .L16
87:                    else if(output > 1900)
0011AE  2076C0     MOV #0x76C, W0
0011B0  200001     MOV #0x0, W1
0011B2  78011E     MOV [W14], W2
0011B4  90019E     MOV [W14+2], W3
0011B6  510F80     SUB W2, W0, [W15]
0011B8  598F81     SUBB W3, W1, [W15]
0011BA  340003     BRA LE, .L16
88:                        output = 1900;
0011BC  2076C0     MOV #0x76C, W0
0011BE  200001     MOV #0x0, W1
0011C0  BE8F00     MOV.D W0, [W14]
89:                    
90:                    motor1_Move(output, m);
0011C2  78001E     MOV [W14], W0
0011C4  9000AE     MOV [W14+4], W1
0011C6  07FEE8     RCALL motor1_Move
91:                     IO_RC3_Toggle();    
0011C8  807120     MOV LATC, W0
0011CA  DE0043     LSR W0, #3, W0
0011CC  604061     AND.B W0, #0x1, W0
0011CE  A20400     BTG.B W0, #0
0011D0  604061     AND.B W0, #0x1, W0
0011D2  FB8000     ZE W0, W0
0011D4  600061     AND W0, #0x1, W0
0011D6  DD0043     SL W0, #3, W0
0011D8  807121     MOV LATC, W1
0011DA  A13001     BCLR W1, #3
0011DC  700001     IOR W0, W1, W0
0011DE  887120     MOV W0, LATC
0011E0  370003     BRA .L7
92:                }
0011E8  78044F     MOV [--W15], W8
0011EA  FA8000     ULNK
0011EC  060000     RETURN
93:                
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/qei.c  -----------------------------------
1:                 
2:                 
3:                 
4:                 #include "qei.h"
5:                 
6:                 
7:                 
8:                 
9:                 void qei_Init(){
00198C  FA0000     LNK #0x0
10:                    
11:                    RPINR14bits.QEB1R = 0x37;
00198E  8035E1     MOV RPINR14, W1
001990  280FF0     MOV #0x80FF, W0
001992  608080     AND W1, W0, W1
001994  237000     MOV #0x3700, W0
001996  700001     IOR W0, W1, W0
001998  8835E0     MOV W0, RPINR14
12:                    RPINR14bits.QEA1R = 0x36;
00199A  8035E1     MOV RPINR14, W1
00199C  2FF800     MOV #0xFF80, W0
00199E  608080     AND W1, W0, W1
0019A0  200360     MOV #0x36, W0
0019A2  700001     IOR W0, W1, W0
0019A4  8835E0     MOV W0, RPINR14
13:                    
14:                    QEI1IOCbits.QFDIV = 0x07;
0019A6  800E11     MOV QEI1IOC, W1
0019A8  238000     MOV #0x3800, W0
0019AA  700001     IOR W0, W1, W0
0019AC  880E10     MOV W0, QEI1IOC
15:                    QEI1IOCbits.FLTREN = 1;    
0019AE  A8C1C3     BSET 0x1C3, #6
16:                }
0019B0  FA8000     ULNK
0019B2  060000     RETURN
17:                
18:                void qei_On(){    
0019B4  FA0000     LNK #0x0
19:                    
20:                     QEI1CONbits.QEIEN = 1;
0019B6  A8E1C1     BSET 0x1C1, #7
21:                }
0019B8  FA8000     ULNK
0019BA  060000     RETURN
22:                
23:                int16_t qei_ReadPos(void){
0019BC  FA0000     LNK #0x0
24:                    
25:                    return  POS1CNTL;    
0019BE  800E30     MOV POS1CNTL, W0
26:                };
0019C0  FA8000     ULNK
0019C2  060000     RETURN
27:                
28:                void qei_WritePos(int16_t value){
0019C4  FA0002     LNK #0x2
0019C6  780F00     MOV W0, [W14]
29:                    POS1HLD = 0;
0019C8  EF21CA     CLR POS1HLD
30:                    POS1CNTL = value;
0019CA  78001E     MOV [W14], W0
0019CC  880E30     MOV W0, POS1CNTL
31:                }
0019CE  FA8000     ULNK
0019D0  060000     RETURN
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/process.c  -------------------------------
1:                 /* 
2:                  * File:   process1ms.c
3:                  * Author: mjacobs
4:                  *
5:                  * Created on December 12, 2018, 8:56 AM
6:                  */
7:                 #include "mcc_generated_files/mcc.h"
8:                 #include "mcc_generated_files/system.h"
9:                 
10:                #include "process.h"
11:                #include "qei.h"
12:                #include "sh1106.h"
13:                #include "motor.h"
14:                #include "adc.h"
15:                #include "servo.h"
16:                
17:                //static ch0pressure;
18:                static ch1pressure;
19:                
20:                //static ch0zeropressure;
21:                static ch1zeropressure;
22:                
23:                static ENCSW encsw = SW_INVALID;
24:                static ENCSWEVENT encswevent = SW_NOEVENT;
25:                static int16_t encvalue = 0;
26:                static int16_t adcvalue = 0;
27:                static int16_t testvalue = 0;
28:                
29:                static uint8_t fdisplay = 1;
30:                static uint8_t fmpressure = 0;
31:                
32:                static int16_t pressuresetvalue = 0;
33:                static int16_t ierror = 0;
34:                static int16_t perror = 0;
35:                static int16_t masterpressure = 0;
36:                
37:                // called every 100 us
38:                void loop100us(void){
0011EE  FA0002     LNK #0x2
39:                    
40:                    //IO_RC3_Toggle(); 
41:                    MOTOR_MOTION mm = motor1_isMotion();
0011F0  07FE8A     RCALL motor1_isMotion
0011F2  780F00     MOV W0, [W14]
42:                    if(mm == MOTOR_UPMOTION){
0011F4  78001E     MOV [W14], W0
0011F6  500FE1     SUB W0, #0x1, [W15]
0011F8  3A0005     BRA NZ, .L2
43:                        if(probe1_GetLimit() == PROBE_UPLIMIT){
0011FA  07FE13     RCALL probe1_GetLimit
0011FC  E00000     CP0 W0
0011FE  3A0009     BRA NZ, .L1
44:                            motor1_Off();
001200  07FE77     RCALL motor1_Off
001202  370007     BRA .L1
45:                        }
46:                    }
47:                    else if(mm == MOTOR_DOWNMOTION){        
001204  78001E     MOV [W14], W0
001206  500FE2     SUB W0, #0x2, [W15]
001208  3A0004     BRA NZ, .L1
48:                    if(probe1_GetLimit() == PROBE_DOWNLIMIT)
00120A  07FE0B     RCALL probe1_GetLimit
00120C  500FE1     SUB W0, #0x1, [W15]
00120E  3A0001     BRA NZ, .L1
49:                       motor1_Off();
001210  07FE6F     RCALL motor1_Off
50:                    }
51:                }
001212  FA8000     ULNK
001214  060000     RETURN
52:                
53:                // called every 1 ms.
54:                void loop1ms(void){ 
001216  FA0002     LNK #0x2
55:                    static uint8_t displayloop = 0;    
56:                    
57:                    encswUpdate();    
001218  07004C     RCALL encswUpdate
58:                    encvalue = (qei_ReadPos() >> 2);
00121A  0703D0     RCALL qei_ReadPos
00121C  DE8042     ASR W0, #2, W0
00121E  888030     MOV W0, encvalue
59:                    //encvalue *= 10;
60:                    if(encvalue < -200)
001220  808031     MOV encvalue, W1
001222  2FF380     MOV #0xFF38, W0
001224  508F80     SUB W1, W0, [W15]
001226  3D0003     BRA GE, .L5
61:                        encvalue = -200;
001228  2FF380     MOV #0xFF38, W0
00122A  888030     MOV W0, encvalue
00122C  370006     BRA .L6
62:                    else if(encvalue > 1000)
00122E  808031     MOV encvalue, W1
001230  203E80     MOV #0x3E8, W0
001232  508F80     SUB W1, W0, [W15]
001234  340002     BRA LE, .L6
63:                        encvalue = 1000;
001236  203E80     MOV #0x3E8, W0
001238  888030     MOV W0, encvalue
64:                    pressuresetvalue = encvalue; 
00123A  808030     MOV encvalue, W0
00123C  888070     MOV W0, pressuresetvalue
65:                    masterpressure = encvalue;
00123E  808030     MOV encvalue, W0
001240  8880A0     MOV W0, masterpressure
66:                 
67:                    ENCSWEVENT event = encswEvent();
001242  070030     RCALL encswEvent
001244  780F00     MOV W0, [W14]
68:                    if(event == SW_CLICKED){
001246  78001E     MOV [W14], W0
001248  500FE1     SUB W0, #0x1, [W15]
00124A  3A0001     BRA NZ, .L7
69:                        //qei_WritePos(0);
70:                        //encvalue = 0;
71:                        testMotor();
00124C  070094     RCALL testMotor
72:                    }    
73:                    
74:                    // display update at 100 ms
75:                    displayloop++;
00124E  BFD018     MOV.B displayloop, WREG
001250  E84000     INC.B W0, W0
001252  B7F018     MOV.B WREG, displayloop
76:                    if(displayloop == 200){
001254  210181     MOV #0x1018, W1
001256  784091     MOV.B [W1], W1
001258  B3CC80     MOV.B #0xC8, W0
00125A  50CF80     SUB.B W1, W0, [W15]
00125C  3A0002     BRA NZ, .L4
77:                        displayloop = 0;
00125E  EF7018     CLR.B displayloop
78:                        loopDisplay();
001260  070010     RCALL loopDisplay
79:                    }    
80:                }
001262  FA8000     ULNK
001264  060000     RETURN
81:                
82:                void config_CH1ZeroValue(){
001266  FA0000     LNK #0x0
83:                    ch1zeropressure = ch1pressure;
001268  808000     MOV ch1pressure, W0
00126A  888010     MOV W0, ch1zeropressure
84:                }
00126C  FA8000     ULNK
00126E  060000     RETURN
85:                
86:                void display_On(void){
001270  FA0000     LNK #0x0
87:                    fdisplay = 1;
001272  B3C010     MOV.B #0x1, W0
001274  B7F042     MOV.B WREG, .L3
88:                }
001276  FA8000     ULNK
001278  060000     RETURN
89:                
90:                void display_Off(void){
00127A  FA0000     LNK #0x0
91:                    fdisplay = 0;
00127C  EF7042     CLR.B .L3
92:                }
00127E  FA8000     ULNK
001280  060000     RETURN
93:                
94:                void loopDisplay(void){
001282  FA0000     LNK #0x0
95:                    
96:                    if((i2c_Ready() == I2C_STATUS_IDLE) && fdisplay){
001284  07FAE3     RCALL i2c_Ready
001286  E00000     CP0 W0
001288  3A0007     BRA NZ, .L12
00128A  BFD042     MOV.B .L3, WREG
00128C  E00400     CP0.B W0
00128E  320004     BRA Z, .L12
97:                        display_Value(adcvalue);
001290  808040     MOV adcvalue, W0
001292  07FC4F     RCALL display_Value
98:                    
99:                        display_Line3(encvalue);
001294  808030     MOV encvalue, W0
001296  07FCAC     RCALL display_Line3
100:                       //display_Line3(triggervalue);
101:                       //display_Line3(testvalue);
102:                   }    
103:               }
001298  FA8000     ULNK
00129A  060000     RETURN
104:               
105:               ENCSW encswRead(void){
00129C  FA0000     LNK #0x0
106:                   return encsw;    
00129E  808200     MOV 0x1040, W0
107:               }
0012A0  FA8000     ULNK
0012A2  060000     RETURN
108:               ENCSWEVENT encswEvent(void){
0012A4  FA0002     LNK #0x2
109:                   ENCSWEVENT event = encswevent;
0012A6  808021     MOV encswevent, W1
0012A8  780F01     MOV W1, [W14]
110:                   encswevent = SW_NOEVENT;
0012AA  EF3004     CLR encswevent
111:                   return event;
0012AC  78001E     MOV [W14], W0
112:               }
0012AE  FA8000     ULNK
0012B0  060000     RETURN
113:               
114:               void encswUpdate(void){
0012B2  FA0000     LNK #0x0
115:                   static uint8_t encswreg = 0xFF;
116:                   static uint16_t statecnt = 0;    
117:                   
118:                   // debounce switch
119:                   encswreg = encswreg << 1;
0012B4  BFD044     MOV.B 0x1044, WREG
0012B6  404000     ADD.B W0, W0, W0
0012B8  B7F044     MOV.B WREG, 0x1044
120:                   if(IO_RC8_GetValue()){        
0012BA  807111     MOV PORTC, W1
0012BC  201000     MOV #0x100, W0
0012BE  608000     AND W1, W0, W0
0012C0  E00000     CP0 W0
0012C2  320004     BRA Z, .L17
121:                       encswreg = encswreg | 1;        
0012C4  BFD044     MOV.B 0x1044, WREG
0012C6  A00400     BSET.B W0, #0
0012C8  B7F044     MOV.B WREG, 0x1044
0012CA  370003     BRA .L18
122:                   }
123:                   else{
124:                       encswreg = encswreg & 0xFE;
0012CC  BFD044     MOV.B 0x1044, WREG
0012CE  A10400     BCLR.B W0, #0
0012D0  B7F044     MOV.B WREG, 0x1044
125:                   }
126:                   
127:                   if(encswreg == 0xFF){
0012D2  BFD044     MOV.B 0x1044, WREG
0012D4  404FE1     ADD.B W0, #0x1, [W15]
0012D6  3A0020     BRA NZ, .L19
128:                       switch(encsw){
0012D8  808200     MOV 0x1040, W0
0012DA  500FE1     SUB W0, #0x1, [W15]
0012DC  320005     BRA Z, .L22
0012DE  500FE1     SUB W0, #0x1, [W15]
0012E0  39000A     BRA NC, .L21
0012E2  500FE2     SUB W0, #0x2, [W15]
0012E4  320015     BRA Z, .L23
129:                           case SW_UP: 
130:                               if(statecnt == 0xFFFF) return;
0012E8  8080B0     MOV statecnt, W0
0012EA  400FE1     ADD W0, #0x1, [W15]
0012EC  320028     BRA Z, .L32
00133E  000000     NOP
001340  370003     BRA .L16
131:                               statecnt++;
0012EE  8080B0     MOV statecnt, W0
0012F0  E80000     INC W0, W0
0012F2  8880B0     MOV W0, statecnt
132:                               return;
0012F4  370029     BRA .L16
133:                           case SW_DOWN:
134:                               if(statecnt < 1000)
0012F6  8080B1     MOV statecnt, W1
0012F8  203E70     MOV #0x3E7, W0
0012FA  508F80     SUB W1, W0, [W15]
0012FC  3E0003     BRA GTU, .L26
135:                                   encswevent = SW_CLICKED;
0012FE  200010     MOV #0x1, W0
001300  888020     MOV W0, encswevent
001302  370002     BRA .L27
136:                               else
137:                                   encswevent = SW_LCLICKED;
001304  200020     MOV #0x2, W0
001306  888020     MOV W0, encswevent
138:                               encsw = SW_UP;
001308  200010     MOV #0x1, W0
00130A  888200     MOV W0, 0x1040
139:                               statecnt = 0;
00130C  EF3016     CLR statecnt
140:                               return;                
00130E  37001C     BRA .L16
141:                           case SW_INVALID:
142:                               encsw = SW_UP;
001310  200010     MOV #0x1, W0
001312  888200     MOV W0, 0x1040
143:                               statecnt = 0;
001314  EF3016     CLR statecnt
144:                               return; 
001316  370018     BRA .L16
145:                           default:
146:                               return;            
0012E6  370030     BRA .L16
147:                       }        
148:                   }
149:                   else if(encswreg == 0){
001318  BFD044     MOV.B 0x1044, WREG
00131A  E00400     CP0.B W0
00131C  3A0015     BRA NZ, .L16
150:                       switch(encsw){
00131E  808200     MOV 0x1040, W0
001320  E00000     CP0 W0
001322  320005     BRA Z, .L29
001324  500FE1     SUB W0, #0x1, [W15]
001326  3A000D     BRA NZ, .L33
151:                           case SW_UP:
152:                               encsw = SW_DOWN;
001328  EF3040     CLR 0x1040
153:                               statecnt = 0;
00132A  EF3016     CLR statecnt
154:                               return;
00132C  37000D     BRA .L16
155:                           case SW_DOWN:
156:                               if(statecnt == 0xFFFF) return;
00132E  8080B0     MOV statecnt, W0
001330  400FE1     ADD W0, #0x1, [W15]
001332  320009     BRA Z, .L34
001346  000000     NOP
157:                               statecnt++;
001334  8080B0     MOV statecnt, W0
001336  E80000     INC W0, W0
001338  8880B0     MOV W0, statecnt
158:                               return;
00133A  000000     NOP
00133C  370005     BRA .L16
159:                           default:
160:                               return;             
001342  000000     NOP
001344  370001     BRA .L16
161:                       }                 
162:                   }        
163:               }
001348  FA8000     ULNK
00134A  060000     RETURN
164:               
165:               void setCH1Value(int16_t p){
00134C  FA0002     LNK #0x2
00134E  780F00     MOV W0, [W14]
166:                   ch1pressure = p;
001350  78009E     MOV [W14], W1
001352  888001     MOV W1, ch1pressure
167:               }
001354  FA8000     ULNK
001356  060000     RETURN
168:               
169:               int16_t getSetPressure(PRESSURE_CH ch){
001358  FA0002     LNK #0x2
00135A  780F00     MOV W0, [W14]
170:                   if(ch == PRES1)
00135C  78001E     MOV [W14], W0
00135E  E00000     CP0 W0
001360  3A0002     BRA NZ, .L37
171:                       return masterpressure;
001362  8080A0     MOV masterpressure, W0
001364  370006     BRA .L38
172:                   if(ch == PRES2)
001366  78001E     MOV [W14], W0
001368  500FE1     SUB W0, #0x1, [W15]
00136A  3A0002     BRA NZ, .L39
173:                       return masterpressure;
00136C  8080A0     MOV masterpressure, W0
00136E  370001     BRA .L38
174:                   return 0;
001370  EB0000     CLR W0
175:               }
001372  FA8000     ULNK
001374  060000     RETURN
176:               
177:               void testMotor(void){
001376  FA0000     LNK #0x0
178:                   
179:                   static uint8_t mode = 1;
180:                   
181:                   if(mode){
001378  BFD043     MOV.B 0x1043, WREG
00137A  E00400     CP0.B W0
00137C  320004     BRA Z, .L41
182:                       servo_Trigger(SERVO1);
00137E  EB0000     CLR W0
001380  07FE58     RCALL servo_Trigger
183:                       mode = 0;
001382  EF7043     CLR.B 0x1043
001384  370006     BRA .L40
184:                   }
185:                   else{        
186:                       // move motor up to limit
187:                       motor1_On();
001386  07FDC3     RCALL motor1_On
188:                       motor1_Move(1200, MOTOR_UPMOTION);
001388  200011     MOV #0x1, W1
00138A  204B00     MOV #0x4B0, W0
00138C  07FE05     RCALL motor1_Move
189:                       mode = 1;
00138E  B3C010     MOV.B #0x1, W0
001390  B7F043     MOV.B WREG, 0x1043
190:                   } 
191:               }
001392  FA8000     ULNK
001394  060000     RETURN
192:               
193:               void test_SetADCValue(int16_t value){
001396  FA0002     LNK #0x2
001398  780F00     MOV W0, [W14]
194:                   adcvalue = value;
00139A  78009E     MOV [W14], W1
00139C  888041     MOV W1, adcvalue
195:               }
00139E  FA8000     ULNK
0013A0  060000     RETURN
196:               
197:               
198:               
199:               
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/motor.c  ---------------------------------
1:                 /* 
2:                  * File:   servo.h
3:                  * Author: mjacobs
4:                  *
5:                  * Created on February 11, 2019, 2:08 PM
6:                  */
7:                 
8:                 
9:                 #include "mcc_generated_files/mcc.h"
10:                #include "mcc_generated_files/system.h"
11:                
12:                
13:                #define FCY     30170937UL
14:                
15:                
16:                #include <libpic30.h>
17:                #include "stddef.h"
18:                #include "motor.h"
19:                #include "process.h"
20:                
21:                static MOTOR_MOTION motor1;
22:                //static MOTOR_MOTION motor2;
23:                
24:                PROBE_LIMIT probe1_GetLimit(void){
000E22  FA0000     LNK #0x0
25:                    
26:                    if(IO_RA4_GetValue() == 1){
000E24  807010     MOV PORTA, W0
000E26  600070     AND W0, #0x10, W0
000E28  E00000     CP0 W0
000E2A  320002     BRA Z, .L37
27:                        return PROBE_UPLIMIT;
000E2C  EB0000     CLR W0
000E2E  370008     BRA .L38
28:                    }else if(IO_RB8_GetValue() == 1){
000E30  807091     MOV PORTB, W1
000E32  201000     MOV #0x100, W0
000E34  608000     AND W1, W0, W0
000E36  E00000     CP0 W0
000E38  320002     BRA Z, .L39
29:                        return PROBE_DOWNLIMIT;
000E3A  200010     MOV #0x1, W0
000E3C  370001     BRA .L38
30:                    }else return PROBE_NOLIMIT;
000E3E  200020     MOV #0x2, W0
31:                }
000E40  FA8000     ULNK
000E42  060000     RETURN
32:                
33:                uint16_t motor_ReadLimits1(void){
000E44  FA0002     LNK #0x2
34:                    
35:                    uint16_t sws = 0;    
000E46  EB0000     CLR W0
000E48  780F00     MOV W0, [W14]
36:                    
37:                    if(IO_RA4_GetValue() == 1)
000E4A  807010     MOV PORTA, W0
000E4C  600070     AND W0, #0x10, W0
000E4E  E00000     CP0 W0
000E50  320001     BRA Z, .L41
38:                        sws = sws | 0x01;
000E52  A0001E     BSET [W14], #0
39:                            
40:                    if(IO_RB8_GetValue() == 1)
000E54  807091     MOV PORTB, W1
000E56  201000     MOV #0x100, W0
000E58  608000     AND W1, W0, W0
000E5A  E00000     CP0 W0
000E5C  320001     BRA Z, .L42
41:                        sws = sws | 0x02;
000E5E  A0101E     BSET [W14], #1
42:                    return sws;    
000E60  78001E     MOV [W14], W0
43:                }
000E62  FA8000     ULNK
000E64  060000     RETURN
44:                
45:                void motor_MoveUptoLimit(void){
000E66  FA0002     LNK #0x2
46:                    PWM_GENERATOR genNum = PWM_GENERATOR_1;
000E68  200010     MOV #0x1, W0
000E6A  780F00     MOV W0, [W14]
47:                    
48:                    PWM_OverrideLowDisable(genNum);   
000E6C  78001E     MOV [W14], W0
000E6E  07FF4A     RCALL _PWM_OverrideLowDisable, .LFE25, .LFB26
49:                    
50:                    IO_RB10_SetHigh();
000E70  A84E15     BSET 0xE15, #2
51:                    
52:                    while(IO_RA4_GetValue() == 0);
000E72  000000     NOP
000E74  807010     MOV PORTA, W0
000E76  600070     AND W0, #0x10, W0
000E78  E00000     CP0 W0
000E7A  32FFFC     BRA Z, .L44
53:                    
54:                    PWM_OverrideLowEnable(genNum);
000E7C  78001E     MOV [W14], W0
000E7E  07FF1A     RCALL _PWM_OverrideLowEnable, .Ltext0, .LFB25, .Letext0, .LFE64
55:                    
56:                    __delay_ms(5);
000E80  24D460     MOV #0x4D46, W0
000E82  200021     MOV #0x2, W1
000E84  0705FE     RCALL ___delay32, .Letext0, .LFE58
57:                    
58:                    IO_RB10_SetLow();    
000E86  A94E15     BCLR 0xE15, #2
59:                }
000E88  FA8000     ULNK
000E8A  060000     RETURN
60:                
61:                void motor_MoveDowntoLimit(void){
000E8C  FA0002     LNK #0x2
62:                    
63:                    PWM_GENERATOR genNum = PWM_GENERATOR_1;
000E8E  200010     MOV #0x1, W0
000E90  780F00     MOV W0, [W14]
64:                    
65:                    PWM_OverrideHighDisable(genNum);   
000E92  78001E     MOV [W14], W0
000E94  07FF87     RCALL _PWM_OverrideHighDisable, .LFE27, .LFB28
66:                    
67:                    IO_RB10_SetHigh();
000E96  A84E15     BSET 0xE15, #2
68:                    
69:                    while(IO_RB8_GetValue() == 0);
000E98  000000     NOP
000E9A  807091     MOV PORTB, W1
000E9C  201000     MOV #0x100, W0
000E9E  608000     AND W1, W0, W0
000EA0  E00000     CP0 W0
000EA2  32FFFB     BRA Z, .L46
70:                    
71:                    PWM_OverrideHighEnable(genNum);
000EA4  78001E     MOV [W14], W0
000EA6  07FF56     RCALL _PWM_OverrideHighEnable, .LFE26, .LFB27
72:                    
73:                    __delay_ms(5);
000EA8  24D460     MOV #0x4D46, W0
000EAA  200021     MOV #0x2, W1
000EAC  0705EA     RCALL ___delay32, .Letext0, .LFE58
74:                    
75:                    IO_RB10_SetLow();     
000EAE  A94E15     BCLR 0xE15, #2
76:                }
000EB0  FA8000     ULNK
000EB2  060000     RETURN
77:                
78:                void motor_MoveUp(void){
000EB4  FA0002     LNK #0x2
79:                    
80:                    PWM_GENERATOR genNum = PWM_GENERATOR_1;
000EB6  200010     MOV #0x1, W0
000EB8  780F00     MOV W0, [W14]
81:                    motor1 = MOTOR_UPMOTION;    
000EBA  200010     MOV #0x1, W0
000EBC  888250     MOV W0, motor1
82:                    PWM_OverrideLowDisable(genNum);    
000EBE  78001E     MOV [W14], W0
000EC0  07FF21     RCALL _PWM_OverrideLowDisable, .LFE25, .LFB26
83:                    IO_RB10_SetHigh();        
000EC2  A84E15     BSET 0xE15, #2
84:                }
000EC4  FA8000     ULNK
000EC6  060000     RETURN
85:                
86:                void motor_MoveDown(void){
000EC8  FA0002     LNK #0x2
87:                    
88:                    PWM_GENERATOR genNum = PWM_GENERATOR_1;
000ECA  200010     MOV #0x1, W0
000ECC  780F00     MOV W0, [W14]
89:                    motor1 = MOTOR_DOWNMOTION;    
000ECE  200020     MOV #0x2, W0
000ED0  888250     MOV W0, motor1
90:                    PWM_OverrideHighDisable(genNum);       
000ED2  78001E     MOV [W14], W0
000ED4  07FF67     RCALL _PWM_OverrideHighDisable, .LFE27, .LFB28
91:                    IO_RB10_SetHigh();    
000ED6  A84E15     BSET 0xE15, #2
92:                }
000ED8  FA8000     ULNK
000EDA  060000     RETURN
93:                
94:                void motor1_Hold(void){
000EDC  FA0002     LNK #0x2
95:                    PWM_GENERATOR genNum = PWM_GENERATOR_1;    
000EDE  200010     MOV #0x1, W0
000EE0  780F00     MOV W0, [W14]
96:                    PWM_OverrideHighEnable(genNum);
000EE2  78001E     MOV [W14], W0
000EE4  07FF37     RCALL _PWM_OverrideHighEnable, .LFE26, .LFB27
97:                    PWM_OverrideLowEnable(genNum);
000EE6  78001E     MOV [W14], W0
000EE8  07FEE5     RCALL _PWM_OverrideLowEnable, .Ltext0, .LFB25, .Letext0, .LFE64
98:                    motor1 = MOTOR_NOMOTION;
000EEA  EF304A     CLR motor1
99:                }
000EEC  FA8000     ULNK
000EEE  060000     RETURN
100:               
101:               void motor1_Off(void){
000EF0  FA0002     LNK #0x2
102:                   PWM_GENERATOR genNum = PWM_GENERATOR_1;
000EF2  200010     MOV #0x1, W0
000EF4  780F00     MOV W0, [W14]
103:                   // disable motor drive
104:                   PWM_OverrideHighEnable(genNum);
000EF6  78001E     MOV [W14], W0
000EF8  07FF2D     RCALL _PWM_OverrideHighEnable, .LFE26, .LFB27
105:                   PWM_OverrideLowEnable(genNum);
000EFA  78001E     MOV [W14], W0
000EFC  07FEDB     RCALL _PWM_OverrideLowEnable, .Ltext0, .LFB25, .Letext0, .LFE64
106:                   IO_RB10_SetLow();   
000EFE  A94E15     BCLR 0xE15, #2
107:                   motor1 = MOTOR_NOMOTION;
000F00  EF304A     CLR motor1
108:               }
000F02  FA8000     ULNK
000F04  060000     RETURN
109:               
110:               MOTOR_MOTION motor1_isMotion(void){
000F06  FA0000     LNK #0x0
111:                   return motor1;
000F08  808250     MOV motor1, W0
112:               }
000F0A  FA8000     ULNK
000F0C  060000     RETURN
113:               
114:               void motor1_On(void){
000F0E  FA0002     LNK #0x2
115:                   PWM_GENERATOR genNum = PWM_GENERATOR_1;    
000F10  200010     MOV #0x1, W0
000F12  780F00     MOV W0, [W14]
116:                   PWM_OverrideHighEnable(genNum);
000F14  78001E     MOV [W14], W0
000F16  07FF1E     RCALL _PWM_OverrideHighEnable, .LFE26, .LFB27
117:                   PWM_OverrideLowEnable(genNum);
000F18  78001E     MOV [W14], W0
000F1A  07FECC     RCALL _PWM_OverrideLowEnable, .Ltext0, .LFB25, .Letext0, .LFE64
118:                   IO_RB10_SetHigh();
000F1C  A84E15     BSET 0xE15, #2
119:                   motor1 = MOTOR_NOMOTION;    
000F1E  EF304A     CLR motor1
120:               }
000F20  FA8000     ULNK
000F22  060000     RETURN
121:               
122:               // motor_Move  +v motor moves down. -v motor moves up
123:               // should never get a 0;
124:               void motor_Move(int8_t v){
000F24  FA0008     LNK #0x8
000F26  984760     MOV.B W0, [W14+6]
125:                   PWM_GENERATOR genNum = PWM_GENERATOR_1;
000F28  200010     MOV #0x1, W0
000F2A  980720     MOV W0, [W14+4]
126:                   MOTOR_MOTION nmm = MOTOR_DOWNMOTION;
000F2C  200020     MOV #0x2, W0
000F2E  780F00     MOV W0, [W14]
127:                   int16_t r = v;
000F30  90406E     MOV.B [W14+6], W0
000F32  FB0000     SE W0, W0
000F34  980710     MOV W0, [W14+2]
128:                   
129:                   // extract direction and scale
130:                   if(v < 0){
000F36  90406E     MOV.B [W14+6], W0
000F38  E00400     CP0.B W0
000F3A  3D000B     BRA GE, .L54
131:                       nmm = MOTOR_UPMOTION;
000F3C  200010     MOV #0x1, W0
000F3E  780F00     MOV W0, [W14]
132:                       r = ~v;
000F40  90406E     MOV.B [W14+6], W0
000F42  FB0100     SE W0, W2
000F44  780002     MOV W2, W0
000F46  EA8000     COM W0, W0
000F48  EA8081     COM W1, W1
000F4A  980710     MOV W0, [W14+2]
133:                       r = r+1;
000F4C  90001E     MOV [W14+2], W0
000F4E  E80000     INC W0, W0
000F50  980710     MOV W0, [W14+2]
134:                   }
135:                   r = (r*8) + 400;
000F52  90001E     MOV [W14+2], W0
000F54  B00320     ADD #0x32, W0
000F56  DD0043     SL W0, #3, W0
000F58  980710     MOV W0, [W14+2]
136:               
137:                   if (nmm != motor1) {
000F5A  808250     MOV motor1, W0
000F5C  78009E     MOV [W14], W1
000F5E  508F80     SUB W1, W0, [W15]
000F60  320015     BRA Z, .L55
138:                       PWM_OverrideHighEnable(genNum);
000F62  90002E     MOV [W14+4], W0
000F64  07FEF7     RCALL _PWM_OverrideHighEnable, .LFE26, .LFB27
139:                       PWM_OverrideLowEnable(genNum);
000F66  90002E     MOV [W14+4], W0
000F68  07FEA5     RCALL _PWM_OverrideLowEnable, .Ltext0, .LFB25, .Letext0, .LFE64
140:                       PWM_DutyCycleSet(genNum, r);
000F6A  90001E     MOV [W14+2], W0
000F6C  780080     MOV W0, W1
000F6E  90002E     MOV [W14+4], W0
000F70  07FF41     RCALL _PWM_DutyCycleSet, .LFE28, .LFB30
141:                       if (nmm == MOTOR_DOWNMOTION) {
000F72  78001E     MOV [W14], W0
000F74  500FE2     SUB W0, #0x2, [W15]
000F76  3A0005     BRA NZ, .L56
142:                           motor1 = MOTOR_DOWNMOTION;
000F78  200020     MOV #0x2, W0
000F7A  888250     MOV W0, motor1
143:                           PWM_OverrideHighDisable(genNum);
000F7C  90002E     MOV [W14+4], W0
000F7E  07FF12     RCALL _PWM_OverrideHighDisable, .LFE27, .LFB28
000F80  370009     BRA .L53
144:                       } else {
145:                           motor1 = MOTOR_UPMOTION;
000F82  200010     MOV #0x1, W0
000F84  888250     MOV W0, motor1
146:                           PWM_OverrideLowDisable(genNum);
000F86  90002E     MOV [W14+4], W0
000F88  07FEBD     RCALL _PWM_OverrideLowDisable, .LFE25, .LFB26
000F8A  370004     BRA .L53
147:                       }
148:                   } else
149:                       PWM_DutyCycleSet(genNum, r);    
000F8C  90001E     MOV [W14+2], W0
000F8E  780080     MOV W0, W1
000F90  90002E     MOV [W14+4], W0
000F92  07FF30     RCALL _PWM_DutyCycleSet, .LFE28, .LFB30
150:               }
000F94  FA8000     ULNK
000F96  060000     RETURN
151:               
152:               void motor1_Move(uint16_t val, MOTOR_MOTION motion){
000F98  FA0006     LNK #0x6
000F9A  980710     MOV W0, [W14+2]
000F9C  980721     MOV W1, [W14+4]
153:                   PWM_GENERATOR genNum = PWM_GENERATOR_1;
000F9E  200010     MOV #0x1, W0
000FA0  780F00     MOV W0, [W14]
154:               
155:                   if (motion != motor1) {
000FA2  808250     MOV motor1, W0
000FA4  9000AE     MOV [W14+4], W1
000FA6  508F80     SUB W1, W0, [W15]
000FA8  320014     BRA Z, .L59
156:                       PWM_OverrideHighEnable(genNum);
000FAA  78001E     MOV [W14], W0
000FAC  07FED3     RCALL _PWM_OverrideHighEnable, .LFE26, .LFB27
157:                       PWM_OverrideLowEnable(genNum);
000FAE  78001E     MOV [W14], W0
000FB0  07FE81     RCALL _PWM_OverrideLowEnable, .Ltext0, .LFB25, .Letext0, .LFE64
158:                       PWM_DutyCycleSet(genNum, val);
000FB2  90009E     MOV [W14+2], W1
000FB4  78001E     MOV [W14], W0
000FB6  07FF1E     RCALL _PWM_DutyCycleSet, .LFE28, .LFB30
159:                       if (motion == MOTOR_DOWNMOTION) {
000FB8  90002E     MOV [W14+4], W0
000FBA  500FE2     SUB W0, #0x2, [W15]
000FBC  3A0005     BRA NZ, .L60
160:                           motor1 = MOTOR_DOWNMOTION;
000FBE  200020     MOV #0x2, W0
000FC0  888250     MOV W0, motor1
161:                           PWM_OverrideHighDisable(genNum);
000FC2  78001E     MOV [W14], W0
000FC4  07FEEF     RCALL _PWM_OverrideHighDisable, .LFE27, .LFB28
000FC6  370008     BRA .L58
162:                       } else {
163:                           motor1 = MOTOR_UPMOTION;
000FC8  200010     MOV #0x1, W0
000FCA  888250     MOV W0, motor1
164:                           PWM_OverrideLowDisable(genNum);
000FCC  78001E     MOV [W14], W0
000FCE  07FE9A     RCALL _PWM_OverrideLowDisable, .LFE25, .LFB26
000FD0  370003     BRA .L58
165:                       }
166:                   } else
167:                       PWM_DutyCycleSet(genNum, val);
000FD2  90009E     MOV [W14+2], W1
000FD4  78001E     MOV [W14], W0
000FD6  07FF0E     RCALL _PWM_DutyCycleSet, .LFE28, .LFB30
168:                   
169:               }
000FD8  FA8000     ULNK
000FDA  060000     RETURN
170:               
171:               // set probe position and set zero pressure value
172:               void probe1_SetStartPos(void){
000FDC  FA0000     LNK #0x0
173:                   
174:                   if (probe1_GetLimit() != PROBE_UPLIMIT) {
000FDE  07FF21     RCALL probe1_GetLimit
000FE0  E00000     CP0 W0
000FE2  320005     BRA Z, .L66
175:                       motor1_On();
000FE4  07FF94     RCALL motor1_On
176:                       motor1_Move(800, MOTOR_UPMOTION);
000FE6  200011     MOV #0x1, W1
000FE8  203200     MOV #0x320, W0
000FEA  07FFD6     RCALL motor1_Move
177:                   }
178:                   while (probe1_GetLimit() != PROBE_UPLIMIT);
000FEC  370001     BRA .L64
000FEE  000000     NOP
000FF0  07FF18     RCALL probe1_GetLimit
000FF2  E00000     CP0 W0
000FF4  3AFFFD     BRA NZ, .L64
179:                   motor1_On();
000FF6  07FF8B     RCALL motor1_On
180:                   motor1_Move(400, MOTOR_DOWNMOTION);
000FF8  200021     MOV #0x2, W1
000FFA  201900     MOV #0x190, W0
000FFC  07FFCD     RCALL motor1_Move
181:                   while (probe1_GetLimit() == PROBE_UPLIMIT);
000FFE  000000     NOP
001000  07FF10     RCALL probe1_GetLimit
001002  E00000     CP0 W0
001004  32FFFD     BRA Z, .L65
182:                   motor1_Off();
001006  07FF74     RCALL motor1_Off
183:               
184:                   __delay_ms(20);
001008  2351A0     MOV #0x351A, W0
00100A  200091     MOV #0x9, W1
00100C  07053A     RCALL ___delay32, .Letext0, .LFE58
185:               
186:                   config_CH1ZeroValue();    
00100E  07012B     RCALL config_CH1ZeroValue
187:               }
001010  FA8000     ULNK
001012  060000     RETURN
188:               
189:               
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/traps.c  -------------
1:                 /**
2:                   System Traps Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     traps.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for handling traps
12:                    using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs traps.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
18:                        Device            :  dsPIC33EP128MC504
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.35
21:                        MPLAB             :  MPLAB X v5.05
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                #include "traps.h"
50:                
51:                #define ERROR_HANDLER __attribute__((interrupt, no_auto_psv, keep, section("error_handler")))
52:                #define ERROR_HANDLER_NORETURN ERROR_HANDLER __attribute__((noreturn))
53:                #define FAILSAFE_STACK_GUARDSIZE 8
54:                
55:                /**
56:                 * a private place to store the error code if we run into a severe error
57:                 */
58:                static uint16_t TRAPS_error_code = -1;
59:                
60:                /**
61:                 * Halts 
62:                 * 
63:                 * @param code error code
64:                 */
65:                void __attribute__((naked, noreturn, weak)) TRAPS_halt_on_error(uint16_t code)
66:                {
001A9E  780F00     MOV W0, [W14]
67:                    TRAPS_error_code = code;
001AA0  78009E     MOV [W14], W1
001AA2  888231     MOV W1, 0x1046
68:                #ifdef __DEBUG    
69:                    __builtin_software_breakpoint();
70:                    /* If we are in debug mode, cause a software breakpoint in the debugger */
71:                #endif
72:                    while(1);
001AA4  37FFFF     BRA .L2
73:                    
74:                }
75:                
76:                /**
77:                 * Sets the stack pointer to a backup area of memory, in case we run into
78:                 * a stack error (in which case we can't really trust the stack pointer)
79:                 */
80:                inline static void use_failsafe_stack(void)
81:                {
001AA6  FA0000     LNK #0x0
82:                    static uint8_t failsafe_stack[32];
83:                    asm volatile (
001AA8  210A00     MOV #0x10A0, W0
001AAA  780780     MOV W0, W15
84:                        "   mov    %[pstack], W15\n"
85:                        :
86:                        : [pstack]"r"(failsafe_stack)
87:                    );
88:                /* Controls where the stack pointer limit is, relative to the end of the
89:                 * failsafe stack
90:                 */    
91:                    SPLIM = (uint16_t)(((uint8_t *)failsafe_stack) + sizeof(failsafe_stack) 
001AAC  210B80     MOV #0x10B8, W0
001AAE  880100     MOV W0, SPLIM
92:                            - FAILSAFE_STACK_GUARDSIZE);
93:                }
001AB0  FA8000     ULNK
001AB2  060000     RETURN
94:                
95:                
96:                /** Oscillator Fail Trap vector**/
97:                void ERROR_HANDLER_NORETURN _OscillatorFail(void)
98:                {
0002FA  F80036     PUSH RCOUNT
99:                    INTCON1bits.OSCFAIL = 0;  //Clear the trap flag
0002FC  A928C0     BCLR INTCON1, #1
100:                   TRAPS_halt_on_error(TRAPS_OSC_FAIL);
0002FE  EB0000     CLR W0
000300  070BCE     RCALL TRAPS_halt_on_error
101:               }
102:               /** Stack Error Trap Vector**/
103:               void ERROR_HANDLER_NORETURN _StackError(void)
104:               {
000302  F80036     PUSH RCOUNT
105:                   /* We use a failsafe stack: the presence of a stack-pointer error
106:                    * means that we cannot trust the stack to operate correctly unless
107:                    * we set the stack pointer to a safe place.
108:                    */
109:                   use_failsafe_stack(); 
000304  070BD0     RCALL _use_failsafe_stack, .LFE0, .LFB1
110:                   INTCON1bits.STKERR = 0;  //Clear the trap flag
000306  A948C0     BCLR INTCON1, #2
111:                   TRAPS_halt_on_error(TRAPS_STACK_ERR);
000308  200010     MOV #0x1, W0
00030A  070BC9     RCALL TRAPS_halt_on_error
112:               }
113:               /** Address error Trap vector**/
114:               void ERROR_HANDLER_NORETURN _AddressError(void)
115:               {
00030C  F80036     PUSH RCOUNT
116:                   INTCON1bits.ADDRERR = 0;  //Clear the trap flag
00030E  A968C0     BCLR INTCON1, #3
117:                   TRAPS_halt_on_error(TRAPS_ADDRESS_ERR);
000310  200020     MOV #0x2, W0
000312  070BC5     RCALL TRAPS_halt_on_error
118:               }
119:               /** Math Error Trap vector**/
120:               void ERROR_HANDLER_NORETURN _MathError(void)
121:               {
000314  F80036     PUSH RCOUNT
122:                   INTCON1bits.MATHERR = 0;  //Clear the trap flag
000316  A988C0     BCLR INTCON1, #4
123:                   TRAPS_halt_on_error(TRAPS_MATH_ERR);
000318  200030     MOV #0x3, W0
00031A  070BC1     RCALL TRAPS_halt_on_error
124:               }
125:               /** DMAC Error Trap vector**/
126:               void ERROR_HANDLER_NORETURN _DMACError(void)
127:               {
00031C  F80036     PUSH RCOUNT
128:                   INTCON1bits.DMACERR = 0;  //Clear the trap flag
00031E  A9A8C0     BCLR INTCON1, #5
129:                   TRAPS_halt_on_error(TRAPS_DMAC_ERR);
000320  200040     MOV #0x4, W0
000322  070BBD     RCALL TRAPS_halt_on_error
130:               }
131:               /** Generic Hard Trap vector**/
132:               void ERROR_HANDLER_NORETURN _HardTrapError(void)
133:               {
000324  F80036     PUSH RCOUNT
134:                   INTCON4bits.SGHT = 0;  //Clear the trap flag
000326  A908C6     BCLR INTCON4, #0
135:                   TRAPS_halt_on_error(TRAPS_HARD_ERR);
000328  200070     MOV #0x7, W0
00032A  070BB9     RCALL TRAPS_halt_on_error
136:               }
137:               /** Generic Soft Trap vector**/
138:               void ERROR_HANDLER_NORETURN _SoftTrapError(void)
139:               {
00032C  F80036     PUSH RCOUNT
140:                   INTCON3bits.DOOVR = 0;  //Clear the trap flag
00032E  A988C4     BCLR INTCON3, #4
141:                   TRAPS_halt_on_error(TRAPS_DOOVR_ERR);
000330  2000A0     MOV #0xA, W0
000332  070BB5     RCALL TRAPS_halt_on_error
142:               }
143:               
144:               
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/tmr5.c  --------------
1:                 
2:                 /**
3:                   TMR5 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr5.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR5 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR5. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
18:                        Device            :  dsPIC33EP128MC504
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.35
21:                        MPLAB             :  MPLAB X v5.05
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include <xc.h>
51:                #include "tmr5.h"
52:                
53:                /**
54:                  Section: Data Type Definitions
55:                */
56:                
57:                /** TMR Driver Hardware Instance Object
58:                
59:                  @Summary
60:                    Defines the object required for the maintainence of the hardware instance.
61:                
62:                  @Description
63:                    This defines the object required for the maintainence of the hardware
64:                    instance. This object exists once per hardware instance of the peripheral.
65:                
66:                  Remarks:
67:                    None.
68:                */
69:                
70:                typedef struct _TMR_OBJ_STRUCT
71:                {
72:                    /* Timer Elapsed */
73:                    bool                                                    timerElapsed;
74:                    /*Software Counter value*/
75:                    uint8_t                                                 count;
76:                
77:                } TMR_OBJ;
78:                
79:                static TMR_OBJ tmr5_obj;
80:                
81:                /**
82:                  Section: Driver Interface
83:                */
84:                
85:                void TMR5_Initialize (void)
86:                {
001826  FA0000     LNK #0x0
87:                    //TMR5 0; 
88:                    TMR5 = 0x00;
001828  EF2118     CLR TMR5
89:                    //Period = 0.000050015 s; Frequency = 30170937 Hz; PR5 1509; 
90:                    PR5 = 0x5E5;
00182A  205E50     MOV #0x5E5, W0
00182C  8808E0     MOV W0, PR5
91:                    //TCKPS 1:1; TON enabled; TSIDL disabled; TCS FOSC/2; TGATE disabled; 
92:                    T5CON = 0x8000;
00182E  280000     MOV #0x8000, W0
001830  880900     MOV W0, T5CON
93:                
94:                    
95:                    IFS1bits.T5IF = false;
001832  A98803     BCLR 0x803, #4
96:                    IEC1bits.T5IE = true;
001834  A88823     BSET 0x823, #4
97:                	
98:                    tmr5_obj.timerElapsed = false;
001836  211000     MOV #0x1100, W0
001838  EB4080     CLR.B W1
00183A  784801     MOV.B W1, [W0]
99:                
100:               }
00183C  FA8000     ULNK
00183E  060000     RETURN
101:               
102:               
103:               
104:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _T5Interrupt (  )
105:               {
000334  F80036     PUSH RCOUNT
000336  BE9F80     MOV.D W0, [W15++]
000338  BE9F82     MOV.D W2, [W15++]
00033A  BE9F84     MOV.D W4, [W15++]
00033C  BE9F86     MOV.D W6, [W15++]
00033E  FA0000     LNK #0x0
106:                   /* Check if the Timer Interrupt/Status is set */
107:               
108:                   //***User Area Begin
109:               
110:                   // ticker function call;
111:                   // ticker is 1 -> Callback function gets called everytime this ISR executes
112:                   TMR5_CallBack();
000340  070A99     RCALL TMR5_CallBack
113:               
114:                   //***User Area End
115:               
116:                   tmr5_obj.count++;
000342  211010     MOV #0x1101, W0
000344  784010     MOV.B [W0], W0
000346  E84080     INC.B W0, W1
000348  211010     MOV #0x1101, W0
00034A  784801     MOV.B W1, [W0]
117:                   tmr5_obj.timerElapsed = true;
00034C  211000     MOV #0x1100, W0
00034E  B3C011     MOV.B #0x1, W1
000350  784801     MOV.B W1, [W0]
118:                   IFS1bits.T5IF = false;
000352  A98803     BCLR 0x803, #4
119:               }
000354  FA8000     ULNK
000356  BE034F     MOV.D [--W15], W6
000358  BE024F     MOV.D [--W15], W4
00035A  BE014F     MOV.D [--W15], W2
00035C  BE004F     MOV.D [--W15], W0
00035E  F90036     POP RCOUNT
000360  064000     RETFIE
120:               
121:               
122:               void TMR5_Period16BitSet( uint16_t value )
123:               {
001840  FA0002     LNK #0x2
001842  780F00     MOV W0, [W14]
124:                   /* Update the counter values */
125:                   PR5 = value;
001844  78009E     MOV [W14], W1
001846  8808E1     MOV W1, PR5
126:                   /* Reset the status information */
127:                   tmr5_obj.timerElapsed = false;
001848  211000     MOV #0x1100, W0
00184A  EB4080     CLR.B W1
00184C  784801     MOV.B W1, [W0]
128:               }
00184E  FA8000     ULNK
001850  060000     RETURN
129:               
130:               uint16_t TMR5_Period16BitGet( void )
131:               {
001852  FA0000     LNK #0x0
132:                   return( PR5 );
001854  8008E0     MOV PR5, W0
133:               }
001856  FA8000     ULNK
001858  060000     RETURN
134:               
135:               void TMR5_Counter16BitSet ( uint16_t value )
136:               {
00185A  FA0002     LNK #0x2
00185C  780F00     MOV W0, [W14]
137:                   /* Update the counter values */
138:                   TMR5 = value;
00185E  78009E     MOV [W14], W1
001860  8808C1     MOV W1, TMR5
139:                   /* Reset the status information */
140:                   tmr5_obj.timerElapsed = false;
001862  211000     MOV #0x1100, W0
001864  EB4080     CLR.B W1
001866  784801     MOV.B W1, [W0]
141:               }
001868  FA8000     ULNK
00186A  060000     RETURN
142:               
143:               uint16_t TMR5_Counter16BitGet( void )
144:               {
00186C  FA0000     LNK #0x0
145:                   return( TMR5 );
00186E  8008C0     MOV TMR5, W0
146:               }
001870  FA8000     ULNK
001872  060000     RETURN
147:               
148:               
149:               void __attribute__ ((weak)) TMR5_CallBack(void)
150:               {
001874  FA0000     LNK #0x0
151:                   // Add your custom callback code here
152:               }
001876  FA8000     ULNK
001878  060000     RETURN
153:               
154:               void TMR5_Start( void )
155:               {
00187A  FA0000     LNK #0x0
156:                   /* Reset the status information */
157:                   tmr5_obj.timerElapsed = false;
00187C  211000     MOV #0x1100, W0
00187E  EB4080     CLR.B W1
001880  784801     MOV.B W1, [W0]
158:               
159:                   /*Enable the interrupt*/
160:                   IEC1bits.T5IE = true;
001882  A88823     BSET 0x823, #4
161:               
162:                   /* Start the Timer */
163:                   T5CONbits.TON = 1;
001884  A8E121     BSET 0x121, #7
164:               }
001886  FA8000     ULNK
001888  060000     RETURN
165:               
166:               void TMR5_Stop( void )
167:               {
00188A  FA0000     LNK #0x0
168:                   /* Stop the Timer */
169:                   T5CONbits.TON = false;
00188C  A9E121     BCLR 0x121, #7
170:               
171:                   /*Disable the interrupt*/
172:                   IEC1bits.T5IE = false;
00188E  A98823     BCLR 0x823, #4
173:               }
001890  FA8000     ULNK
001892  060000     RETURN
174:               
175:               bool TMR5_GetElapsedThenClear(void)
176:               {
001894  FA0002     LNK #0x2
177:                   bool status;
178:                   
179:                   status = tmr5_obj.timerElapsed;
001896  211000     MOV #0x1100, W0
001898  784F10     MOV.B [W0], [W14]
180:               
181:                   if(status == true)
00189A  78401E     MOV.B [W14], W0
00189C  E00400     CP0.B W0
00189E  320003     BRA Z, .L11
182:                   {
183:                       tmr5_obj.timerElapsed = false;
0018A0  211000     MOV #0x1100, W0
0018A2  EB4080     CLR.B W1
0018A4  784801     MOV.B W1, [W0]
184:                   }
185:                   return status;
0018A6  78401E     MOV.B [W14], W0
186:               }
0018A8  FA8000     ULNK
0018AA  060000     RETURN
187:               
188:               int TMR5_SoftwareCounterGet(void)
189:               {
0018AC  FA0000     LNK #0x0
190:                   return tmr5_obj.count;
0018AE  211010     MOV #0x1101, W0
0018B0  784010     MOV.B [W0], W0
0018B2  FB8000     ZE W0, W0
191:               }
0018B4  FA8000     ULNK
0018B6  060000     RETURN
192:               
193:               void TMR5_SoftwareCounterClear(void)
194:               {
0018B8  FA0000     LNK #0x0
195:                   tmr5_obj.count = 0; 
0018BA  211010     MOV #0x1101, W0
0018BC  EB4080     CLR.B W1
0018BE  784801     MOV.B W1, [W0]
196:               }
0018C0  FA8000     ULNK
0018C2  060000     RETURN
197:               
198:               /**
199:                End of File
200:               */
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/tmr2.c  --------------
1:                 
2:                 /**
3:                   TMR2 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr2.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR2 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR2. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
18:                        Device            :  dsPIC33EP128MC504
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.35
21:                        MPLAB             :  MPLAB X v5.05
22:                */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include <xc.h>
51:                #include "tmr2.h"
52:                
53:                /**
54:                  Section: Data Type Definitions
55:                */
56:                
57:                /** TMR Driver Hardware Instance Object
58:                
59:                  @Summary
60:                    Defines the object required for the maintainence of the hardware instance.
61:                
62:                  @Description
63:                    This defines the object required for the maintainence of the hardware
64:                    instance. This object exists once per hardware instance of the peripheral.
65:                
66:                  Remarks:
67:                    None.
68:                */
69:                
70:                typedef struct _TMR_OBJ_STRUCT
71:                {
72:                    /* Timer Elapsed */
73:                    bool                                                    timerElapsed;
74:                    /*Software Counter value*/
75:                    uint8_t                                                 count;
76:                
77:                } TMR_OBJ;
78:                
79:                static TMR_OBJ tmr2_obj;
80:                
81:                /**
82:                  Section: Driver Interface
83:                */
84:                
85:                void TMR2_Initialize (void)
86:                {
0016D0  FA0000     LNK #0x0
87:                    //TMR2 0; 
88:                    TMR2 = 0x00;
0016D2  EF2106     CLR TMR2
89:                    //Period = 0.0000999969 s; Frequency = 30170937 Hz; PR2 3018; 
90:                    PR2 = 0xBCA;
0016D4  20BCA0     MOV #0xBCA, W0
0016D6  880860     MOV W0, PR2
91:                    //TCKPS 1:1; T32 16 Bit; TON enabled; TSIDL disabled; TCS FOSC/2; TGATE disabled; 
92:                    T2CON = 0x8000;
0016D8  280000     MOV #0x8000, W0
0016DA  880880     MOV W0, T2CON
93:                
94:                    
95:                	
96:                    tmr2_obj.timerElapsed = false;
0016DC  210FE0     MOV #0x10FE, W0
0016DE  EB4080     CLR.B W1
0016E0  784801     MOV.B W1, [W0]
97:                
98:                }
0016E2  FA8000     ULNK
0016E4  060000     RETURN
99:                
100:               
101:               
102:               void TMR2_Tasks_16BitOperation( void )
103:               {
0016E6  FA0000     LNK #0x0
104:                   /* Check if the Timer Interrupt/Status is set */
105:                   if(IFS0bits.T2IF)
0016E8  804001     MOV IFS0, W1
0016EA  200800     MOV #0x80, W0
0016EC  608000     AND W1, W0, W0
0016EE  E00000     CP0 W0
0016F0  320009     BRA Z, .L2
106:                   {
107:                       tmr2_obj.count++;
0016F2  210FF0     MOV #0x10FF, W0
0016F4  784010     MOV.B [W0], W0
0016F6  E84080     INC.B W0, W1
0016F8  210FF0     MOV #0x10FF, W0
0016FA  784801     MOV.B W1, [W0]
108:                       tmr2_obj.timerElapsed = true;
0016FC  210FE0     MOV #0x10FE, W0
0016FE  B3C011     MOV.B #0x1, W1
001700  784801     MOV.B W1, [W0]
109:                       IFS0bits.T2IF = false;
001702  A9E800     BCLR IFS0, #7
110:                   }
111:               }
001704  FA8000     ULNK
001706  060000     RETURN
112:               
113:               
114:               void TMR2_Period16BitSet( uint16_t value )
115:               {
001708  FA0002     LNK #0x2
00170A  780F00     MOV W0, [W14]
116:                   /* Update the counter values */
117:                   PR2 = value;
00170C  78009E     MOV [W14], W1
00170E  880861     MOV W1, PR2
118:                   /* Reset the status information */
119:                   tmr2_obj.timerElapsed = false;
001710  210FE0     MOV #0x10FE, W0
001712  EB4080     CLR.B W1
001714  784801     MOV.B W1, [W0]
120:               }
001716  FA8000     ULNK
001718  060000     RETURN
121:               
122:               uint16_t TMR2_Period16BitGet( void )
123:               {
00171A  FA0000     LNK #0x0
124:                   return( PR2 );
00171C  800860     MOV PR2, W0
125:               }
00171E  FA8000     ULNK
001720  060000     RETURN
126:               
127:               void TMR2_Counter16BitSet ( uint16_t value )
128:               {
001722  FA0002     LNK #0x2
001724  780F00     MOV W0, [W14]
129:                   /* Update the counter values */
130:                   TMR2 = value;
001726  78009E     MOV [W14], W1
001728  880831     MOV W1, TMR2
131:                   /* Reset the status information */
132:                   tmr2_obj.timerElapsed = false;
00172A  210FE0     MOV #0x10FE, W0
00172C  EB4080     CLR.B W1
00172E  784801     MOV.B W1, [W0]
133:               }
001730  FA8000     ULNK
001732  060000     RETURN
134:               
135:               uint16_t TMR2_Counter16BitGet( void )
136:               {
001734  FA0000     LNK #0x0
137:                   return( TMR2 );
001736  800830     MOV TMR2, W0
138:               }
001738  FA8000     ULNK
00173A  060000     RETURN
139:               
140:               
141:               
142:               void TMR2_Start( void )
143:               {
00173C  FA0000     LNK #0x0
144:                   /* Reset the status information */
145:                   tmr2_obj.timerElapsed = false;
00173E  210FE0     MOV #0x10FE, W0
001740  EB4080     CLR.B W1
001742  784801     MOV.B W1, [W0]
146:               
147:               
148:                   /* Start the Timer */
149:                   T2CONbits.TON = 1;
001744  A8E111     BSET 0x111, #7
150:               }
001746  FA8000     ULNK
001748  060000     RETURN
151:               
152:               void TMR2_Stop( void )
153:               {
00174A  FA0000     LNK #0x0
154:                   /* Stop the Timer */
155:                   T2CONbits.TON = false;
00174C  A9E111     BCLR 0x111, #7
156:               
157:               }
00174E  FA8000     ULNK
001750  060000     RETURN
158:               
159:               bool TMR2_GetElapsedThenClear(void)
160:               {
001752  FA0002     LNK #0x2
161:                   bool status;
162:                   
163:                   status = tmr2_obj.timerElapsed;
001754  210FE0     MOV #0x10FE, W0
001756  784F10     MOV.B [W0], [W14]
164:               
165:                   if(status == true)
001758  78401E     MOV.B [W14], W0
00175A  E00400     CP0.B W0
00175C  320003     BRA Z, .L11
166:                   {
167:                       tmr2_obj.timerElapsed = false;
00175E  210FE0     MOV #0x10FE, W0
001760  EB4080     CLR.B W1
001762  784801     MOV.B W1, [W0]
168:                   }
169:                   return status;
001764  78401E     MOV.B [W14], W0
170:               }
001766  FA8000     ULNK
001768  060000     RETURN
171:               
172:               int TMR2_SoftwareCounterGet(void)
173:               {
00176A  FA0000     LNK #0x0
174:                   return tmr2_obj.count;
00176C  210FF0     MOV #0x10FF, W0
00176E  784010     MOV.B [W0], W0
001770  FB8000     ZE W0, W0
175:               }
001772  FA8000     ULNK
001774  060000     RETURN
176:               
177:               void TMR2_SoftwareCounterClear(void)
178:               {
001776  FA0000     LNK #0x0
179:                   tmr2_obj.count = 0; 
001778  210FF0     MOV #0x10FF, W0
00177A  EB4080     CLR.B W1
00177C  784801     MOV.B W1, [W0]
180:               }
00177E  FA8000     ULNK
001780  060000     RETURN
181:               
182:               /**
183:                End of File
184:               */
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/system.h  ------------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the system.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
17:                        Device            :  dsPIC33EP128MC504
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.35
20:                        MPLAB             :  MPLAB X v5.05
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include "xc.h"
46:                #include "stdint.h"
47:                #include "system_types.h"
48:                
49:                #ifndef SYSTEM_H
50:                #define	SYSTEM_H
51:                /**
52:                 * Initializes the CPU core control register.
53:                 * @example
54:                 * <code>
55:                 * SYSTEM_CORCONInitialize();
56:                 * </code>
57:                 */
58:                inline static void SYSTEM_CORCONInitialize()
59:                {
60:                    CORCON = (CORCON & 0x00F2) | CORCON_MODE_PORVALUES;    // POR value
61:                }
62:                
63:                /**
64:                 * Sets the CPU core control register operating mode to a value that is decided by the
65:                 * SYSTEM_CORCON_MODES argument.
66:                 * @param modeValue SYSTEM_CORCON_MODES initialization mode specifier
67:                 * @example
68:                 * <code>
69:                 * SYSTEM_CORCONModeOperatingSet(CORCON_MODE_ENABLEALLSATNORMAL_ROUNDUNBIASED);
70:                 * </code>
71:                 */
72:                inline static void SYSTEM_CORCONModeOperatingSet(SYSTEM_CORCON_MODES modeValue)
73:                {
0019D2  FA0002     LNK #0x2
0019D4  780F00     MOV W0, [W14]
74:                    CORCON = (CORCON & 0x00F2) | modeValue;
0019D6  800221     MOV CORCON, W1
0019D8  200F20     MOV #0xF2, W0
0019DA  608000     AND W1, W0, W0
0019DC  70001E     IOR W0, [W14], W0
0019DE  880220     MOV W0, CORCON
75:                }
0019E0  FA8000     ULNK
0019E2  060000     RETURN
76:                
77:                /**
78:                 * Sets the value of CPU core control register.
79:                 * @param value value that needs to be written to the CPU core control register
80:                 * @example
81:                 * <code>
82:                 *  SYSTEM_CORCONRegisterValueSet(0x00E2);
83:                 * </code>
84:                 */
85:                inline static void SYSTEM_CORCONRegisterValueSet(uint16_t value)
86:                {
87:                    CORCON = value;
88:                }
89:                
90:                /**
91:                 * Gets the value of CPU core control register.
92:                 * @return value of the CPU core control register
93:                 * @example
94:                 * <code>
95:                 * corconSave = SYSTEM_CORCONRegisterValueGet();
96:                 * </code>
97:                 */
98:                inline static uint16_t SYSTEM_CORCONRegisterValueGet(void)
99:                {    
100:                   return CORCON;
101:               }
102:               
103:               
104:               /**
105:                * Gets the base address of the DEVID register for the currently selected device
106:                * @return base address of the DEVID register
107:                * @example
108:                * <code>
109:                * uint32_t devIdAddress;
110:                * devIdAddress = SYSTEM_DeviceIdRegisterAddressGet();
111:                * </code>
112:                */
113:               inline static uint32_t SYSTEM_DeviceIdRegisterAddressGet(void)
114:               {
115:                   return __DEVID_BASE;
116:               }
117:               
118:               /**
119:                * @Param
120:                   none
121:                * @Returns
122:                   none
123:                * @Description
124:                   Initializes the device to the default states configured in the
125:                *                  MCC GUI
126:                * @Example
127:                   SYSTEM_Initialize(void);
128:                */
129:               void SYSTEM_Initialize(void);
130:               #endif	/* SYSTEM_H */
131:               /**
132:                End of File
133:               */
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/system.c  ------------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the sysetm.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
17:                        Device            :  dsPIC33EP128MC504
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.35
20:                        MPLAB             :  MPLAB X v5.05
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include "pin_manager.h"
46:                #include "clock.h"
47:                #include "system.h"
48:                #include "system_types.h"
49:                #include "pwm.h"
50:                #include "interrupt_manager.h"
51:                #include "traps.h"
52:                #include "tmr5.h"
53:                #include "tmr2.h"
54:                
55:                void SYSTEM_Initialize(void)
56:                {
0019F0  FA0000     LNK #0x0
57:                    PIN_MANAGER_Initialize();
0019F2  07000A     RCALL PIN_MANAGER_Initialize
58:                    CLOCK_Initialize();
0019F4  07FFA3     RCALL CLOCK_Initialize
59:                    INTERRUPT_Initialize();
0019F6  070023     RCALL INTERRUPT_Initialize
60:                    PWM_Initialize();
0019F8  07FCD4     RCALL PWM_Initialize
61:                    TMR5_Initialize();
0019FA  07FF15     RCALL TMR5_Initialize
62:                    TMR2_Initialize();
0019FC  07FE69     RCALL TMR2_Initialize
63:                    INTERRUPT_GlobalEnable();
0019FE  07FFF2     RCALL INTERRUPT_GlobalEnable
64:                    SYSTEM_CORCONModeOperatingSet(CORCON_MODE_PORVALUES);
001A00  200200     MOV #0x20, W0
001A02  07FFE7     RCALL SYSTEM_CORCONModeOperatingSet
65:                }
001A04  FA8000     ULNK
001A06  060000     RETURN
66:                
67:                /**
68:                 End of File
69:                */
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/reset.c  -------------
1:                 /**
2:                   RESET Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     reset.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the RESET driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This header file provides implementations for driver APIs for RESET.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
17:                        Device            :  dsPIC33EP128MC504
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.35
20:                        MPLAB             :  MPLAB X v5.05
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdbool.h>
46:                #include <stdint.h>
47:                #include "xc.h"
48:                #include "reset.h"
49:                
50:                /**
51:                 Section: Local Variables
52:                */
53:                
54:                /**
55:                 Section: Function prototypes
56:                */
57:                static bool RESET_CauseFromSoftware(uint16_t resetCause);
58:                static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause);
59:                static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause);
60:                static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause);
61:                static bool RESET_CauseFromExternal(uint16_t resetCause);
62:                static bool RESET_CauseFromTrap(uint16_t resetCause);
63:                static void RESET_CauseClear(RESET_MASKS resetFlagMask);
64:                
65:                uint16_t RESET_GetCause(void)
66:                {
0014BE  FA0000     LNK #0x0
67:                    return RCON;
0014C0  803A00     MOV RCON, W0
68:                }
0014C2  FA8000     ULNK
0014C4  060000     RETURN
69:                
70:                void __attribute__ ((weak)) RESET_CauseHandler(void)
71:                {
0014C6  FA0002     LNK #0x2
72:                    uint16_t resetCause = RESET_GetCause();
0014C8  07FFFA     RCALL RESET_GetCause
0014CA  780F00     MOV W0, [W14]
73:                    if(RESET_CauseFromTrap(resetCause))
0014CC  78001E     MOV [W14], W0
0014CE  070024     RCALL _RESET_CauseFromTrap, .LFE1, .LFB2
0014D0  E00400     CP0.B W0
0014D2  320002     BRA Z, .L3
74:                    { 
75:                      RESET_CauseClear(RESET_MASK_TRAPR); 
0014D4  280000     MOV #0x8000, W0
0014D6  070071     RCALL _RESET_CauseClear, .LFE7, .LFB8
76:                      //Do something 
77:                    }
78:                    if(RESET_CauseFromIllegalOpcode(resetCause))
0014D8  78001E     MOV [W14], W0
0014DA  07002A     RCALL _RESET_CauseFromIllegalOpcode, .LFE2, .LFB3
0014DC  E00400     CP0.B W0
0014DE  320002     BRA Z, .L4
79:                    { 
80:                      RESET_CauseClear(RESET_MASK_IOPUWR); 
0014E0  240000     MOV #0x4000, W0
0014E2  07006B     RCALL _RESET_CauseClear, .LFE7, .LFB8
81:                      //Do something 
82:                    }
83:                    if(RESET_CauseFromConfigurationMismatch(resetCause))
0014E4  78001E     MOV [W14], W0
0014E6  070032     RCALL _RESET_CauseFromConfigurationMismatch, .LFE3, .LFB4
0014E8  E00400     CP0.B W0
0014EA  320002     BRA Z, .L5
84:                    { 
85:                      RESET_CauseClear(RESET_MASK_CM); 
0014EC  202000     MOV #0x200, W0
0014EE  070065     RCALL _RESET_CauseClear, .LFE7, .LFB8
86:                      //Do something 
87:                    }
88:                    if(RESET_CauseFromExternal(resetCause))
0014F0  78001E     MOV [W14], W0
0014F2  07003A     RCALL _RESET_CauseFromExternal, .LFE4, .LFB5
0014F4  E00400     CP0.B W0
0014F6  320002     BRA Z, .L6
89:                    { 
90:                      RESET_CauseClear(RESET_MASK_EXTR); 
0014F8  200800     MOV #0x80, W0
0014FA  07005F     RCALL _RESET_CauseClear, .LFE7, .LFB8
91:                      //Do something 
92:                    }
93:                    if(RESET_CauseFromSoftware(resetCause))
0014FC  78001E     MOV [W14], W0
0014FE  070042     RCALL _RESET_CauseFromSoftware, .LFE5, .LFB6
001500  E00400     CP0.B W0
001502  320002     BRA Z, .L7
94:                    { 
95:                      RESET_CauseClear(RESET_MASK_SWR); 
001504  200400     MOV #0x40, W0
001506  070059     RCALL _RESET_CauseClear, .LFE7, .LFB8
96:                      //Do something 
97:                    }
98:                    if(RESET_CauseFromWatchdogTimer(resetCause))
001508  78001E     MOV [W14], W0
00150A  07004A     RCALL _RESET_CauseFromWatchdogTimer, .LFE6, .LFB7
00150C  E00400     CP0.B W0
00150E  320002     BRA Z, .L2
99:                    { 
100:                     RESET_CauseClear(RESET_MASK_WDTO); 
001510  200100     MOV #0x10, W0
001512  070053     RCALL _RESET_CauseClear, .LFE7, .LFB8
101:                     //Do something 
102:                   }
103:               }
001514  FA8000     ULNK
001516  060000     RETURN
104:               
105:               static bool RESET_CauseFromTrap(uint16_t resetCause)
106:               {
001518  FA0004     LNK #0x4
00151A  980710     MOV W0, [W14+2]
107:                   bool resetStatus = false;
00151C  EB4000     CLR.B W0
00151E  784F00     MOV.B W0, [W14]
108:                   if(resetCause & RESET_MASK_TRAPR)
001520  90001E     MOV [W14+2], W0
001522  E00000     CP0 W0
001524  3D0002     BRA GE, .L10
109:                   { 
110:                     resetStatus = true; 
001526  B3C010     MOV.B #0x1, W0
001528  784F00     MOV.B W0, [W14]
111:                   }
112:                   return resetStatus;
00152A  78401E     MOV.B [W14], W0
113:               }
00152C  FA8000     ULNK
00152E  060000     RETURN
114:               
115:               static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause)
116:               {
001530  FA0004     LNK #0x4
001532  980710     MOV W0, [W14+2]
117:                   bool resetStatus = false;
001534  EB4000     CLR.B W0
001536  784F00     MOV.B W0, [W14]
118:                   if(resetCause & RESET_MASK_IOPUWR)
001538  90009E     MOV [W14+2], W1
00153A  240000     MOV #0x4000, W0
00153C  608000     AND W1, W0, W0
00153E  E00000     CP0 W0
001540  320002     BRA Z, .L12
119:                   { 
120:                     resetStatus = true; 
001542  B3C010     MOV.B #0x1, W0
001544  784F00     MOV.B W0, [W14]
121:                   }
122:                   return resetStatus;
001546  78401E     MOV.B [W14], W0
123:               }
001548  FA8000     ULNK
00154A  060000     RETURN
124:               
125:               static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause)
126:               {
00154C  FA0004     LNK #0x4
00154E  980710     MOV W0, [W14+2]
127:                   bool resetStatus = false;
001550  EB4000     CLR.B W0
001552  784F00     MOV.B W0, [W14]
128:                   if(resetCause & RESET_MASK_CM)
001554  90009E     MOV [W14+2], W1
001556  202000     MOV #0x200, W0
001558  608000     AND W1, W0, W0
00155A  E00000     CP0 W0
00155C  320002     BRA Z, .L14
129:                   { 
130:                     resetStatus = true; 
00155E  B3C010     MOV.B #0x1, W0
001560  784F00     MOV.B W0, [W14]
131:                   }
132:                   return resetStatus;
001562  78401E     MOV.B [W14], W0
133:               }
001564  FA8000     ULNK
001566  060000     RETURN
134:               
135:               static bool RESET_CauseFromExternal(uint16_t resetCause)
136:               {
001568  FA0004     LNK #0x4
00156A  980710     MOV W0, [W14+2]
137:                   bool resetStatus = false;
00156C  EB4000     CLR.B W0
00156E  784F00     MOV.B W0, [W14]
138:                   if(resetCause & RESET_MASK_EXTR)
001570  90009E     MOV [W14+2], W1
001572  200800     MOV #0x80, W0
001574  608000     AND W1, W0, W0
001576  E00000     CP0 W0
001578  320002     BRA Z, .L16
139:                   { 
140:                     resetStatus = true; 
00157A  B3C010     MOV.B #0x1, W0
00157C  784F00     MOV.B W0, [W14]
141:                   }
142:                   return resetStatus;
00157E  78401E     MOV.B [W14], W0
143:               }
001580  FA8000     ULNK
001582  060000     RETURN
144:               
145:               static bool RESET_CauseFromSoftware(uint16_t resetCause)
146:               {
001584  FA0004     LNK #0x4
001586  980710     MOV W0, [W14+2]
147:                   bool resetStatus = false;
001588  EB4000     CLR.B W0
00158A  784F00     MOV.B W0, [W14]
148:                   if(resetCause & RESET_MASK_SWR)
00158C  90009E     MOV [W14+2], W1
00158E  200400     MOV #0x40, W0
001590  608000     AND W1, W0, W0
001592  E00000     CP0 W0
001594  320002     BRA Z, .L18
149:                   { 
150:                     resetStatus = true; 
001596  B3C010     MOV.B #0x1, W0
001598  784F00     MOV.B W0, [W14]
151:                   }
152:                   return resetStatus;
00159A  78401E     MOV.B [W14], W0
153:               }
00159C  FA8000     ULNK
00159E  060000     RETURN
154:               
155:               static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause)
156:               {
0015A0  FA0004     LNK #0x4
0015A2  980710     MOV W0, [W14+2]
157:                   bool resetStatus = false;
0015A4  EB4000     CLR.B W0
0015A6  784F00     MOV.B W0, [W14]
158:                   if(resetCause & RESET_MASK_WDTO)
0015A8  90001E     MOV [W14+2], W0
0015AA  600070     AND W0, #0x10, W0
0015AC  E00000     CP0 W0
0015AE  320002     BRA Z, .L20
159:                   { 
160:                     resetStatus = true;
0015B0  B3C010     MOV.B #0x1, W0
0015B2  784F00     MOV.B W0, [W14]
161:                   }
162:                   return resetStatus;
0015B4  78401E     MOV.B [W14], W0
163:               }
0015B6  FA8000     ULNK
0015B8  060000     RETURN
164:               
165:               static void RESET_CauseClear(RESET_MASKS resetFlagMask)
166:               { 
0015BA  FA0002     LNK #0x2
0015BC  780F00     MOV W0, [W14]
167:                    RCON = RCON & (~resetFlagMask); 
0015BE  EA809E     COM [W14], W1
0015C0  803A00     MOV RCON, W0
0015C2  608000     AND W1, W0, W0
0015C4  883A00     MOV W0, RCON
168:               } 
0015C6  FA8000     ULNK
0015C8  060000     RETURN
169:               
170:               void RESET_CauseClearAll()
171:               { 
0015CA  FA0000     LNK #0x0
172:                   RCON = 0x00; 
0015CC  EF2740     CLR RCON
173:               }
0015CE  FA8000     ULNK
0015D0  060000     RETURN
174:               /**
175:                End of File
176:               */
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/pwm.h  ---------------
1:                 /**
2:                   PWM Generated Driver API Header File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     pwm.h
9:                 
10:                  @Summary
11:                    This is the generated header file for the PWM driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This header file provides APIs for driver for PWM.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
17:                        Device            :  dsPIC33EP128MC504
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.35
20:                        MPLAB 	          :  MPLAB X v5.05
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #ifndef _PWM_H
46:                #define _PWM_H
47:                
48:                /**
49:                  Section: Included Files
50:                */
51:                
52:                #include <xc.h>
53:                #include <stdint.h>
54:                #include <stdbool.h>
55:                #include <stdlib.h>
56:                
57:                #ifdef __cplusplus  // Provide C++ Compatibility
58:                
59:                    extern "C" {
60:                
61:                #endif
62:                
63:                /**
64:                  Section: Data Types
65:                */
66:                
67:                /** PWM Generator Definition
68:                 
69:                 @Summary 
70:                   Defines the PWM generators available for PWM
71:                 
72:                 @Description
73:                   This routine defines the PWM generators that are available for the module to use.
74:                 
75:                 Remarks:
76:                   None
77:                 */
78:                typedef enum 
79:                {
80:                    PWM_GENERATOR_1 =  1,       
81:                    PWM_GENERATOR_2 =  2,       
82:                    PWM_GENERATOR_3 =  3,       
83:                } PWM_GENERATOR;
84:                
85:                /**
86:                  Section: Interface Routines
87:                */
88:                
89:                /**
90:                  @Summary
91:                    Initializes hardware and data for the given instance of the PWM module
92:                
93:                  @Description
94:                    This routine initializes hardware for the instance of the PWM module,
95:                    using the hardware initialization given data.  It also initializes all
96:                    necessary internal data.
97:                
98:                  @Param
99:                    None.
100:               
101:                 @Returns
102:                   None
103:                
104:                 @Example 
105:                   <code>
106:                   bool status;
107:                   uint16_t masterPeriod,masterDutyCycle;
108:                   uint16_t postscaler,compareValue;
109:               
110:                   postscaler = 0x1;
111:                   compareValue = 0x1;
112:               
113:                   masterPeriod = 0xFFFF;
114:                   masterDutyCycle = 0xFF;
115:               
116:               
117:                   PWM_Initialize();
118:               
119:                   PWM_ModuleDisable();
120:               
121:                   PWM_MasterDutyCycleSet(masterDutyCycle);
122:                   PWM_PrimaryMasterPeriodSet(period);
123:               
124:                   PWM_SpecialEventPrimaryInterruptDisable();
125:                   PWM_SpecialEventTriggerInterruptFlagClear();
126:                   PWM_PrimarySyncOutputDisable();
127:                   PWM_SpecialEventPrimaryPostscalerSet(postscaler);
128:                   PWM_SpecialEventPrimaryCompareValueSet(compareValue);
129:                   PWM_PrimarySyncOutputEnable();
130:                   PWM_SpecialEventPrimaryInterruptEnable();
131:               
132:                   PWM_ModuleEnable();
133:                   </code>
134:               */
135:               void PWM_Initialize (void);
136:               
137:               /**
138:                 @Summary
139:                   Enables the PWM module.
140:               
141:                 @Description
142:                   This routine is used to enable the PWM module.
143:               
144:                 @Param
145:                   None.
146:               
147:                 @Returns
148:                   None
149:                
150:                 @Example 
151:                   Refer to the example of PWM_Initialize();
152:               */
153:               inline static void PWM_ModuleEnable(void)
154:               {
001782  FA0000     LNK #0x0
155:               	PTCONbits.PTEN = true; 
001784  A8EC01     BSET 0xC01, #7
156:               }
001786  FA8000     ULNK
001788  060000     RETURN
157:               
158:               /**
159:                 @Summary
160:                   Disables the PWM module.
161:               
162:                 @Description
163:                   This routine is used to disable the PWM module.
164:               
165:                 @Param
166:                   None.
167:               
168:                 @Returns
169:                   None
170:                
171:                 @Example 
172:                   Refer to the example of PWM_Initialize();
173:               */
174:               inline static void PWM_ModuleDisable(void)
175:               {
176:               	PTCONbits.PTEN = false; 
177:               }
178:               
179:               /**
180:                 @Summary
181:                   Used to set the PWM master duty cycle register.
182:               
183:                 @Description
184:                   This routine is used to set the PWM master duty cycle register.
185:               
186:                 @Param
187:                   masterDutyCycle - Master Duty Cyle value.
188:               
189:                 @Returns
190:                   None
191:                
192:                 @Example 
193:                   Refer to the example of PWM_Initialize();
194:               */
195:               inline static void PWM_MasterDutyCycleSet(uint16_t masterDutyCycle)
196:               {
197:                   MDC = masterDutyCycle;
198:               }
199:               
200:               /**
201:                 @Summary
202:                   Sets the period value for the Primary Master Time Base generator.
203:               
204:                 @Description
205:                   This routine is used to set the period value for the Primary Master Time Base generator.
206:               
207:                 @Param
208:                   period - Period value.
209:               
210:                 @Returns
211:                   None
212:                
213:                 @Example 
214:                   Refer to the example of PWM_Initialize();
215:               */
216:               inline static void PWM_PrimaryMasterPeriodSet(uint16_t period)
217:               {
218:                   PTPER = period;
219:               }
220:               
221:               /**
222:                 @Summary
223:                   Enables synchronization output from the Primary PWM timebase generator.
224:               
225:                 @Description
226:                   This routine is used to enable synchronization output from the Primary PWM timebase generator.
227:               
228:                 @Param
229:                   None.
230:               
231:                 @Returns
232:                   None
233:                
234:                 @Example 
235:                   Refer to the example of PWM_Initialize();
236:               */ 
237:               inline static void PWM_PrimarySyncOutputEnable(void)
238:               {
239:               	PTCONbits.SYNCOEN = true; 
240:               }
241:               
242:               /**
243:                 @Summary
244:                   Disables synchronization output from the Primary PWM timebase generator.
245:               
246:                 @Description
247:                   This routine is used to disbale synchronization output from the Primary PWM timebase generator.
248:               
249:                 @Param
250:                   None.
251:               
252:                 @Returns
253:                   None
254:                
255:                 @Example 
256:                   Refer to the example of PWM_Initialize();
257:               */  
258:               inline static void PWM_PrimarySyncOutputDisable(void)
259:               {
260:               	PTCONbits.SYNCOEN = false; 
261:               }
262:               
263:               /**
264:                 @Summary
265:                  Sets the postscaler value for the PWM special event trigger from the Primary time base generator.
266:               
267:                 @Description
268:                   This routine is used to set the postscaler value for the PWM special event trigger from the Primary time base generator.
269:               
270:                 @Param
271:                   postscaler - Special event postscaler value.
272:               
273:                 @Returns
274:                   None
275:                
276:                 @Example 
277:                   Refer to the example of PWM_Initialize();
278:               */  
279:               inline static void PWM_SpecialEventPrimaryPostscalerSet(uint16_t postscaler)
280:               {
281:                   PTCONbits.SEVTPS = postscaler;
282:               }
283:               
284:               /**
285:                 @Summary
286:                   Sets the compare value for the Special Event Trigger from the Primary time base generator.
287:               
288:                 @Description
289:                   This routine is used to set the compare value for the Special Event Trigger from the Primary time base generator.
290:               
291:                 @Param
292:                   compareValue - Compare Value.
293:               
294:                 @Returns
295:                   None
296:                
297:                 @Example 
298:                   Refer to the example of PWM_Initialize();
299:               */  
300:               inline static void PWM_SpecialEventPrimaryCompareValueSet(uint16_t compareValue)
301:               {
302:                   SEVTCMP = compareValue;
303:               }
304:               
305:               /**
306:                 @Summary
307:                   Clears PWM Special Event Trigger interrupt request flag
308:               
309:                 @Description
310:                   This routine is used to clear PWM Special Event Trigger interrupt request flag
311:               
312:                 @Param
313:                   None.
314:               
315:                 @Returns
316:                   None
317:                
318:                 @Example 
319:                   Refer to the example of PWM_Initialize();
320:               */ 
321:               inline static void PWM_SpecialEventTriggerInterruptFlagClear(void)
322:               {
323:                   IFS3bits.PSEMIF = false;
324:               }
325:               
326:               /**
327:                 @Summary
328:                   Enables interrupt request for Special Event Trigger from the Primary time base generator.
329:               
330:                 @Description
331:                   This routine is used to enable interrupt request for Special Event Trigger from the Primary time base generator.
332:               
333:                 @Param
334:                   None.
335:               
336:                 @Returns
337:                   None
338:                
339:                 @Example 
340:                   Refer to the example of PWM_Initialize();
341:               */  
342:               inline static void PWM_SpecialEventPrimaryInterruptEnable(void)
343:               {
344:               	PTCONbits.SEIEN = true; 
345:               }
346:               
347:               /**
348:                 @Summary
349:                   Disables interrupt request for Special Event Trigger from the Primary time base generator.
350:               
351:                 @Description
352:                   This routine is used to disable interrupt request for Special Event Trigger from the Primary time base generator.
353:               
354:                 @Param
355:                   None.
356:               
357:                 @Returns
358:                   None
359:                
360:                 @Example 
361:                   Refer to the example of PWM_Initialize();
362:               */  
363:               inline static void PWM_SpecialEventPrimaryInterruptDisable(void)
364:               {
365:               	PTCONbits.SEIEN = false; 
366:               }
367:               
368:               /**
369:                 @Summary
370:                   Enables PWM latched fault mode for specific instance.
371:               
372:                 @Description
373:                   This routine is used to enable PWM latched fault mode for specific instance.
374:               
375:                 @Param
376:                   genNum - PWM generator instance number.
377:               
378:                 @Returns
379:                   None
380:                
381:                 @Example 
382:                   <code>    
383:                   PWM_GENERATOR genNum;
384:                   
385:                   genNum = PWM_GENERATOR_1;
386:                   PWM_FaultModeLatchEnable(genNum);
387:                   </code>
388:               */ 
389:               inline static void PWM_FaultModeLatchEnable(PWM_GENERATOR genNum)
390:               {
391:                   switch(genNum) { 
392:                       case PWM_GENERATOR_1:
393:                               __builtin_write_PWMSFR(&FCLCON1, (FCLCON1 & 0xFFFC), &PWMKEY);                
394:                               break;       
395:                       case PWM_GENERATOR_2:
396:                               __builtin_write_PWMSFR(&FCLCON2, (FCLCON2 & 0xFFFC), &PWMKEY);                
397:                               break;       
398:                       case PWM_GENERATOR_3:
399:                               __builtin_write_PWMSFR(&FCLCON3, (FCLCON3 & 0xFFFC), &PWMKEY);                
400:                               break;       
401:                       default:break;    
402:                   }
403:               }
404:               
405:               /**
406:                 @Summary
407:                   Disables PWM latched fault mode for specific instance.
408:               
409:                 @Description
410:                   This routine is used to disable PWM latched fault mode for specific instance.
411:               
412:                 @Param
413:                   genNum - PWM generator instance number.
414:               
415:                 @Returns
416:                   None
417:                
418:                 @Example 
419:                   <code>    
420:                   PWM_GENERATOR genNum;
421:                   
422:                   genNum = PWM_GENERATOR_1;
423:                   PWM_FaultModeLatchDisable(genNum);
424:                   </code>
425:               */  
426:               inline static void PWM_FaultModeLatchDisable(PWM_GENERATOR genNum)
427:               {
428:                   switch(genNum) { 
429:                       case PWM_GENERATOR_1: 
430:                               __builtin_write_PWMSFR(&FCLCON1, (FCLCON1 | 0x0003), &PWMKEY);
431:                               break;       
432:                       case PWM_GENERATOR_2: 
433:                               __builtin_write_PWMSFR(&FCLCON2, (FCLCON2 | 0x0003), &PWMKEY);
434:                               break;       
435:                       case PWM_GENERATOR_3: 
436:                               __builtin_write_PWMSFR(&FCLCON3, (FCLCON3 | 0x0003), &PWMKEY);
437:                               break;       
438:                       default:break;   
439:                   }   
440:               }
441:               
442:               /**
443:                 @Summary
444:                   Clears PWM interupt request flag for specific instance.
445:               
446:                 @Description
447:                   This routine is used to clear PWM interupt request flag for specific instance.
448:               
449:                 @Param
450:                   genNum - PWM generator instance number.
451:               
452:                 @Returns
453:                   None
454:                
455:                 @Example 
456:                   <code>    
457:                   PWM_GENERATOR genNum;
458:                   
459:                   genNum = PWM_GENERATOR_1;
460:                   PWM_InterruptFlagClear(genNum);
461:                   </code>
462:               */ 
463:               inline static void PWM_InterruptFlagClear(PWM_GENERATOR genNum)
464:               {	
465:                   switch(genNum) { 
466:                       case PWM_GENERATOR_1:
467:                               IFS5bits.PWM1IF = false;                 
468:                               break;       
469:                       case PWM_GENERATOR_2:
470:                               IFS5bits.PWM2IF = false;                 
471:                               break;       
472:                       case PWM_GENERATOR_3:
473:                               IFS6bits.PWM3IF = false;                 
474:                               break;       
475:                       default:break;    
476:                   }
477:               }
478:               
479:               /**
480:                 @Summary
481:                   Clears PWM fault status for specific instance.
482:               
483:                 @Description
484:                   This routine is used to clear PWM fault status for specific instance.
485:               
486:                 @Param
487:                   genNum - PWM generator instance number.
488:               
489:                 @Returns
490:                   None
491:                
492:                 @Example 
493:                   <code>    
494:                   PWM_GENERATOR genNum;
495:                   
496:                   genNum = PWM_GENERATOR_1;
497:                   PWM_FaultInterruptStatusClear(genNum);
498:                   </code>
499:               */ 
500:               inline static void PWM_FaultInterruptStatusClear(PWM_GENERATOR genNum)
501:               {
502:                   switch(genNum) { 
503:                       case PWM_GENERATOR_1:
504:                               PWMCON1bits.FLTIEN = false;
505:                               PWMCON1bits.FLTIEN = true;                
506:                               break;       
507:                       case PWM_GENERATOR_2:
508:                               PWMCON2bits.FLTIEN = false;
509:                               PWMCON2bits.FLTIEN = true;                
510:                               break;       
511:                       case PWM_GENERATOR_3:
512:                               PWMCON3bits.FLTIEN = false;
513:                               PWMCON3bits.FLTIEN = true;                
514:                               break;       
515:                       default:break;    
516:                   }
517:               }
518:               
519:               /**
520:                 @Summary
521:                   Gets PWM fault status for specific instance.
522:               
523:                 @Description
524:                   This routine is used to get PWM fault status for specific instance.
525:               
526:                 @Param
527:                   genNum - PWM generator instance number.
528:               
529:                 @Returns
530:                   Fault interrupt status value.
531:                
532:                 @Example 
533:                   <code>    
534:                   bool status;
535:                   PWM_GENERATOR genNum;
536:                   
537:                   genNum = PWM_GENERATOR_1;
538:                   status = PWM_FaultInterruptStatusGet(genNum);
539:                   </code>
540:               */ 
541:               inline static bool PWM_FaultInterruptStatusGet(PWM_GENERATOR genNum)
542:               {		
543:                   switch(genNum) { 
544:                       case PWM_GENERATOR_1:
545:                               return PWMCON1bits.FLTSTAT;                
546:                               break;       
547:                       case PWM_GENERATOR_2:
548:                               return PWMCON2bits.FLTSTAT;                
549:                               break;       
550:                       case PWM_GENERATOR_3:
551:                               return PWMCON3bits.FLTSTAT;                
552:                               break;       
553:                       default:break;    
554:                   }
555:               }
556:               
557:               /**
558:                 @Summary
559:                   Clears PWM current limit status for specific instance.
560:               
561:                 @Description
562:                   This routine is used to clear PWM current limit status for specific instance.
563:               
564:                 @Param
565:                   genNum - PWM generator instance number.
566:               
567:                 @Returns
568:                   None
569:                
570:                 @Example 
571:                   <code>    
572:                   PWM_GENERATOR genNum;
573:                   
574:                   genNum = PWM_GENERATOR_1;
575:                   PWM_CurrentLimitInterruptStatusClear(genNum);
576:                   </code>
577:               */ 
578:               inline static void PWM_CurrentLimitInterruptStatusClear(PWM_GENERATOR genNum)
579:               {
580:                   switch(genNum) { 
581:                       case PWM_GENERATOR_1:
582:                               PWMCON1bits.CLIEN = false;
583:                               PWMCON1bits.CLIEN = true;                
584:                               break;       
585:                       case PWM_GENERATOR_2:
586:                               PWMCON2bits.CLIEN = false;
587:                               PWMCON2bits.CLIEN = true;                
588:                               break;       
589:                       case PWM_GENERATOR_3:
590:                               PWMCON3bits.CLIEN = false;
591:                               PWMCON3bits.CLIEN = true;                
592:                               break;       
593:                       default:break;    
594:                   }
595:               }
596:               
597:               /**
598:                 @Summary
599:                   Gets PWM current limit status for specific instance.
600:               
601:                 @Description
602:                   This routine is used to get PWM current limit status for specific instance.
603:               
604:                 @Param
605:                   genNum - PWM generator instance number.
606:               
607:                 @Returns
608:                   Current Limit interrupt status value.
609:                
610:                 @Example 
611:                   <code>    
612:                   bool status;
613:                   PWM_GENERATOR genNum;
614:                   
615:                   genNum = PWM_GENERATOR_1;
616:                   status = PWM_CurrentLimitInterruptStatusGet(genNum);
617:                   </code>
618:               */  
619:               inline static bool PWM_CurrentLimitInterruptStatusGet(PWM_GENERATOR genNum)
620:               {	
621:                   switch(genNum) { 
622:                       case PWM_GENERATOR_1:
623:                               return PWMCON1bits.CLSTAT;                
624:                               break;       
625:                       case PWM_GENERATOR_2:
626:                               return PWMCON2bits.CLSTAT;                
627:                               break;       
628:                       case PWM_GENERATOR_3:
629:                               return PWMCON3bits.CLSTAT;                
630:                               break;       
631:                       default:break;    
632:                   }
633:               }
634:               
635:               /**
636:                 @Summary
637:                   Clears PWM trigger status for specific instance.
638:               
639:                 @Description
640:                   This routine is used to clear PWM trigger status for specific instance.
641:               
642:                 @Param
643:                   genNum - PWM generator instance number.
644:               
645:                 @Returns
646:                   None
647:                
648:                 @Example 
649:                   <code>    
650:                   PWM_GENERATOR genNum;
651:                   
652:                   genNum = PWM_GENERATOR_1;
653:                   PWM_TriggerInterruptStatusClear(genNum);
654:                   </code>
655:               */ 
656:               inline static void PWM_TriggerInterruptStatusClear(PWM_GENERATOR genNum)
657:               {
658:                   switch(genNum) { 
659:                       case PWM_GENERATOR_1:
660:                               PWMCON1bits.TRGIEN = false;
661:                               PWMCON1bits.TRGIEN = true;                
662:                               break;       
663:                       case PWM_GENERATOR_2:
664:                               PWMCON2bits.TRGIEN = false;
665:                               PWMCON2bits.TRGIEN = true;                
666:                               break;       
667:                       case PWM_GENERATOR_3:
668:                               PWMCON3bits.TRGIEN = false;
669:                               PWMCON3bits.TRGIEN = true;                
670:                               break;       
671:                       default:break;    
672:                   }
673:               }
674:               
675:               /**
676:                 @Summary
677:                   Gets PWM trigger status for specific instance.
678:               
679:                 @Description
680:                   This routine is used to get PWM trigger status for specific instance.
681:               
682:                 @Param
683:                   genNum - PWM generator instance number.
684:               
685:                 @Returns
686:                   Trigger interrupt status value.
687:                
688:                 @Example 
689:                   <code>    
690:                   bool status;
691:                   PWM_GENERATOR genNum;
692:                   
693:                   genNum = PWM_GENERATOR_1;
694:                   status = PWM_TriggerInterruptStatusGet(genNum);
695:                   </code>
696:               */  
697:               inline static bool PWM_TriggerInterruptStatusGet(PWM_GENERATOR genNum)
698:               {
699:                   switch(genNum) { 
700:                       case PWM_GENERATOR_1:
701:                               return PWMCON1bits.TRGSTAT;                
702:                               break;       
703:                       case PWM_GENERATOR_2:
704:                               return PWMCON2bits.TRGSTAT;                
705:                               break;       
706:                       case PWM_GENERATOR_3:
707:                               return PWMCON3bits.TRGSTAT;                
708:                               break;       
709:                       default:break;  
710:                   }
711:               }
712:               
713:               /**
714:                 @Summary
715:                   Enables PWM override on PWML output for specific instance.
716:               
717:                 @Description
718:                   This routine is used to enable PWM override on PWML output for specific instance.
719:               
720:                 @Param
721:                   genNum - PWM generator instance number.
722:               
723:                 @Returns
724:                   None
725:                
726:                 @Example 
727:                   <code>    
728:                   PWM_GENERATOR genNum;
729:                   
730:                   genNum = PWM_GENERATOR_1;
731:                   PWM_OverrideLowEnable(genNum);
732:                   </code>
733:               */  
734:               inline static void PWM_OverrideLowEnable(PWM_GENERATOR genNum)
735:               {
000CB4  FA0002     LNK #0x2
000CB6  780F00     MOV W0, [W14]
736:                   switch(genNum) { 
000CB8  78001E     MOV [W14], W0
000CBA  500FE2     SUB W0, #0x2, [W15]
000CBC  32000D     BRA Z, .L4
000CBE  500FE3     SUB W0, #0x3, [W15]
000CC0  320014     BRA Z, .L5
000CC2  500FE1     SUB W0, #0x1, [W15]
000CC4  3A001C     BRA NZ, .L7
737:                       case PWM_GENERATOR_1:
738:                               __builtin_write_PWMSFR(&IOCON1, (IOCON1 | 0x0100), &PWMKEY);                
000CC6  806110     MOV IOCON1, W0
000CC8  A08000     BSET W0, #8
000CCA  20C1E3     MOV #0xC1E, W3
000CCC  243211     MOV #0x4321, W1
000CCE  2ABCD2     MOV #0xABCD, W2
000CD0  780982     MOV W2, [W3]
000CD2  780981     MOV W1, [W3]
000CD4  886110     MOV W0, IOCON1
739:                               break;       
000CD6  370014     BRA .L1
740:                       case PWM_GENERATOR_2:
741:                               __builtin_write_PWMSFR(&IOCON2, (IOCON2 | 0x0100), &PWMKEY);                
000CD8  806210     MOV IOCON2, W0
000CDA  A08000     BSET W0, #8
000CDC  20C1E3     MOV #0xC1E, W3
000CDE  243211     MOV #0x4321, W1
000CE0  2ABCD2     MOV #0xABCD, W2
000CE2  780982     MOV W2, [W3]
000CE4  780981     MOV W1, [W3]
000CE6  886210     MOV W0, IOCON2
742:                               break;       
000CE8  37000B     BRA .L1
743:                       case PWM_GENERATOR_3:
744:                               __builtin_write_PWMSFR(&IOCON3, (IOCON3 | 0x0100), &PWMKEY);                
000CEA  806310     MOV IOCON3, W0
000CEC  A08000     BSET W0, #8
000CEE  20C1E3     MOV #0xC1E, W3
000CF0  243211     MOV #0x4321, W1
000CF2  2ABCD2     MOV #0xABCD, W2
000CF4  780982     MOV W2, [W3]
000CF6  780981     MOV W1, [W3]
000CF8  886310     MOV W0, IOCON3
745:                               break;       
000CFA  000000     NOP
000CFC  370001     BRA .L1
746:                       default:break;  
000CFE  000000     NOP
747:                   }
748:               }
000D00  FA8000     ULNK
000D02  060000     RETURN
749:               
750:               /**
751:                 @Summary
752:                   Disables PWM override on PWML output for specific instance.
753:               
754:                 @Description
755:                   This routine is used to disable PWM override on PWML output for specific instance.
756:               
757:                 @Param
758:                   genNum - PWM generator instance number.
759:               
760:                 @Returns
761:                   None
762:                
763:                 @Example 
764:                   <code>    
765:                   PWM_GENERATOR genNum;
766:                   
767:                   genNum = PWM_GENERATOR_1;
768:                   PWM_OverrideLowDisable(genNum);
769:                   </code>
770:               */  
771:               inline static void PWM_OverrideLowDisable(PWM_GENERATOR genNum)
772:               {
000D04  FA0002     LNK #0x2
000D06  780F00     MOV W0, [W14]
773:                   switch(genNum) { 
000D08  78001E     MOV [W14], W0
000D0A  500FE2     SUB W0, #0x2, [W15]
000D0C  32000D     BRA Z, .L11
000D0E  500FE3     SUB W0, #0x3, [W15]
000D10  320014     BRA Z, .L12
000D12  500FE1     SUB W0, #0x1, [W15]
000D14  3A001C     BRA NZ, .L14
774:                       case PWM_GENERATOR_1:
775:                               __builtin_write_PWMSFR(&IOCON1, (IOCON1 & 0xFEFF), &PWMKEY);
000D16  806110     MOV IOCON1, W0
000D18  A18000     BCLR W0, #8
000D1A  20C1E3     MOV #0xC1E, W3
000D1C  243211     MOV #0x4321, W1
000D1E  2ABCD2     MOV #0xABCD, W2
000D20  780982     MOV W2, [W3]
000D22  780981     MOV W1, [W3]
000D24  886110     MOV W0, IOCON1
776:                               break;       
000D26  370014     BRA .L8
777:                       case PWM_GENERATOR_2:
778:                               __builtin_write_PWMSFR(&IOCON2, (IOCON2 & 0xFEFF), &PWMKEY);
000D28  806210     MOV IOCON2, W0
000D2A  A18000     BCLR W0, #8
000D2C  20C1E3     MOV #0xC1E, W3
000D2E  243211     MOV #0x4321, W1
000D30  2ABCD2     MOV #0xABCD, W2
000D32  780982     MOV W2, [W3]
000D34  780981     MOV W1, [W3]
000D36  886210     MOV W0, IOCON2
779:                               break;       
000D38  37000B     BRA .L8
780:                       case PWM_GENERATOR_3:
781:                               __builtin_write_PWMSFR(&IOCON3, (IOCON3 & 0xFEFF), &PWMKEY);
000D3A  806310     MOV IOCON3, W0
000D3C  A18000     BCLR W0, #8
000D3E  20C1E3     MOV #0xC1E, W3
000D40  243211     MOV #0x4321, W1
000D42  2ABCD2     MOV #0xABCD, W2
000D44  780982     MOV W2, [W3]
000D46  780981     MOV W1, [W3]
000D48  886310     MOV W0, IOCON3
782:                               break;       
000D4A  000000     NOP
000D4C  370001     BRA .L8
783:                       default:break;  
000D4E  000000     NOP
784:                   }
785:               }
000D50  FA8000     ULNK
000D52  060000     RETURN
786:               
787:               /**
788:                 @Summary
789:                   Enables PWM override on PWMH output for specific instance.
790:               
791:                 @Description
792:                   This routine is used to enable PWM override on PWMH output for specific instance.
793:               
794:                 @Param
795:                   genNum - PWM generator instance number.
796:               
797:                 @Returns
798:                   None
799:                
800:                 @Example 
801:                   <code>    
802:                   PWM_GENERATOR genNum;
803:                   
804:                   genNum = PWM_GENERATOR_1;
805:                   PWM_OverrideHighEnable(genNum);
806:                   </code>
807:               */  
808:               inline static void PWM_OverrideHighEnable(PWM_GENERATOR genNum)
809:               {
000D54  FA0002     LNK #0x2
000D56  780F00     MOV W0, [W14]
810:                   switch(genNum) { 
000D58  78001E     MOV [W14], W0
000D5A  500FE2     SUB W0, #0x2, [W15]
000D5C  32000D     BRA Z, .L18
000D5E  500FE3     SUB W0, #0x3, [W15]
000D60  320014     BRA Z, .L19
000D62  500FE1     SUB W0, #0x1, [W15]
000D64  3A001C     BRA NZ, .L21
811:                       case PWM_GENERATOR_1:
812:                               __builtin_write_PWMSFR(&IOCON1, (IOCON1 | 0x0200), &PWMKEY);                
000D66  806110     MOV IOCON1, W0
000D68  A09000     BSET W0, #9
000D6A  20C1E3     MOV #0xC1E, W3
000D6C  243211     MOV #0x4321, W1
000D6E  2ABCD2     MOV #0xABCD, W2
000D70  780982     MOV W2, [W3]
000D72  780981     MOV W1, [W3]
000D74  886110     MOV W0, IOCON1
813:                               break;       
000D76  370014     BRA .L15
814:                       case PWM_GENERATOR_2:
815:                               __builtin_write_PWMSFR(&IOCON2, (IOCON2 | 0x0200), &PWMKEY);                
000D78  806210     MOV IOCON2, W0
000D7A  A09000     BSET W0, #9
000D7C  20C1E3     MOV #0xC1E, W3
000D7E  243211     MOV #0x4321, W1
000D80  2ABCD2     MOV #0xABCD, W2
000D82  780982     MOV W2, [W3]
000D84  780981     MOV W1, [W3]
000D86  886210     MOV W0, IOCON2
816:                               break;       
000D88  37000B     BRA .L15
817:                       case PWM_GENERATOR_3:
818:                               __builtin_write_PWMSFR(&IOCON3, (IOCON3 | 0x0200), &PWMKEY);                
000D8A  806310     MOV IOCON3, W0
000D8C  A09000     BSET W0, #9
000D8E  20C1E3     MOV #0xC1E, W3
000D90  243211     MOV #0x4321, W1
000D92  2ABCD2     MOV #0xABCD, W2
000D94  780982     MOV W2, [W3]
000D96  780981     MOV W1, [W3]
000D98  886310     MOV W0, IOCON3
819:                               break;       
000D9A  000000     NOP
000D9C  370001     BRA .L15
820:                       default:break;  
000D9E  000000     NOP
821:                   }
822:               }
000DA0  FA8000     ULNK
000DA2  060000     RETURN
823:               
824:               /**
825:                 @Summary
826:                   Disables PWM override on PWMH output for specific instance.
827:               
828:                 @Description
829:                   This routine is used to disable PWM override on PWMH output for specific instance.
830:               
831:                 @Param
832:                   genNum - PWM generator instance number.
833:               
834:                 @Returns
835:                   None
836:                
837:                 @Example 
838:                   <code>    
839:                   PWM_GENERATOR genNum;
840:                   
841:                   genNum = PWM_GENERATOR_1;
842:                   PWM_OverrideHighDisable(genNum);
843:                   </code>
844:               */  
845:               inline static void PWM_OverrideHighDisable(PWM_GENERATOR genNum)
846:               {
000DA4  FA0002     LNK #0x2
000DA6  780F00     MOV W0, [W14]
847:                   switch(genNum) { 
000DA8  78001E     MOV [W14], W0
000DAA  500FE2     SUB W0, #0x2, [W15]
000DAC  32000D     BRA Z, .L25
000DAE  500FE3     SUB W0, #0x3, [W15]
000DB0  320014     BRA Z, .L26
000DB2  500FE1     SUB W0, #0x1, [W15]
000DB4  3A001C     BRA NZ, .L28
848:                       case PWM_GENERATOR_1:   
849:                               __builtin_write_PWMSFR(&IOCON1, (IOCON1 & 0xFDFF), &PWMKEY);
000DB6  806110     MOV IOCON1, W0
000DB8  A19000     BCLR W0, #9
000DBA  20C1E3     MOV #0xC1E, W3
000DBC  243211     MOV #0x4321, W1
000DBE  2ABCD2     MOV #0xABCD, W2
000DC0  780982     MOV W2, [W3]
000DC2  780981     MOV W1, [W3]
000DC4  886110     MOV W0, IOCON1
850:                               break;       
000DC6  370014     BRA .L22
851:                       case PWM_GENERATOR_2:   
852:                               __builtin_write_PWMSFR(&IOCON2, (IOCON2 & 0xFDFF), &PWMKEY);
000DC8  806210     MOV IOCON2, W0
000DCA  A19000     BCLR W0, #9
000DCC  20C1E3     MOV #0xC1E, W3
000DCE  243211     MOV #0x4321, W1
000DD0  2ABCD2     MOV #0xABCD, W2
000DD2  780982     MOV W2, [W3]
000DD4  780981     MOV W1, [W3]
000DD6  886210     MOV W0, IOCON2
853:                               break;       
000DD8  37000B     BRA .L22
854:                       case PWM_GENERATOR_3:   
855:                               __builtin_write_PWMSFR(&IOCON3, (IOCON3 & 0xFDFF), &PWMKEY);
000DDA  806310     MOV IOCON3, W0
000DDC  A19000     BCLR W0, #9
000DDE  20C1E3     MOV #0xC1E, W3
000DE0  243211     MOV #0x4321, W1
000DE2  2ABCD2     MOV #0xABCD, W2
000DE4  780982     MOV W2, [W3]
000DE6  780981     MOV W1, [W3]
000DE8  886310     MOV W0, IOCON3
856:                               break;       
000DEA  000000     NOP
000DEC  370001     BRA .L22
857:                       default:break;  
000DEE  000000     NOP
858:                   }
859:               }
000DF0  FA8000     ULNK
000DF2  060000     RETURN
860:               
861:               /**
862:                 @Summary
863:                   Updates PWM override data bits with the requested value for a specific instance.
864:               
865:                 @Description
866:                   This routine is used to updates PWM override data bits with the requested value for a specific instance.
867:               
868:                 @Param
869:                   genNum          - PWM generator instance number.
870:                   overrideData    - Override data
871:               
872:                 @Returns
873:                   None
874:                
875:                 @Example 
876:                   <code>    
877:                   PWM_GENERATOR genNum;
878:                   uint16_t overrideData;
879:               
880:                   overrideData = 0x01;
881:                   
882:                   genNum = PWM_GENERATOR_1;
883:                   PWM_OverrideDataSet(genNum, overrideData);
884:                   </code>
885:               */  
886:               inline static void PWM_OverrideDataSet(PWM_GENERATOR genNum,uint16_t overrideData)
887:               {
888:                   switch(genNum) { 
889:                       case PWM_GENERATOR_1:
890:                               overrideData = ((overrideData & 0xFFFC)<<6);
891:                               __builtin_write_PWMSFR(&IOCON1, (IOCON1 | overrideData), &PWMKEY);                
892:                               break;       
893:                       case PWM_GENERATOR_2:
894:                               overrideData = ((overrideData & 0xFFFC)<<6);
895:                               __builtin_write_PWMSFR(&IOCON2, (IOCON2 | overrideData), &PWMKEY);                
896:                               break;       
897:                       case PWM_GENERATOR_3:
898:                               overrideData = ((overrideData & 0xFFFC)<<6);
899:                               __builtin_write_PWMSFR(&IOCON3, (IOCON3 | overrideData), &PWMKEY);                
900:                               break;       
901:                       default:break;  
902:                   }
903:               }
904:               
905:               /**
906:                 @Summary
907:                   Sets the PWM duty cycle for specific instance.
908:               
909:                 @Description
910:                   This routine is used to set the PWM duty cycle for specific instance.
911:               
912:                 @Param
913:                   genNum      - PWM generator instance number.
914:                   dutyCycle   - Duty cycle value
915:               
916:                 @Returns
917:                   None
918:                
919:                 @Example 
920:                   <code>    
921:                   PWM_GENERATOR genNum;
922:                   uint16_t dutyCycle;
923:               
924:                   dutyCycle = 0x01;
925:                   
926:                   genNum = PWM_GENERATOR_1;
927:                   PWM_DutyCycleSet(genNum, dutyCycle);
928:                   </code>
929:               */  
930:               inline static void PWM_DutyCycleSet(PWM_GENERATOR genNum,uint16_t dutyCycle)
931:               {
000DF4  FA0004     LNK #0x4
000DF6  780F00     MOV W0, [W14]
000DF8  980711     MOV W1, [W14+2]
00178A  FA0004     LNK #0x4
00178C  780F00     MOV W0, [W14]
00178E  980711     MOV W1, [W14+2]
932:                   switch(genNum) { 
000DFA  78001E     MOV [W14], W0
000DFC  500FE2     SUB W0, #0x2, [W15]
000DFE  320007     BRA Z, .L32
000E00  500FE3     SUB W0, #0x3, [W15]
000E02  320008     BRA Z, .L33
000E04  500FE1     SUB W0, #0x1, [W15]
000E06  3A000A     BRA NZ, .L35
001790  78001E     MOV [W14], W0
001792  500FE2     SUB W0, #0x2, [W15]
001794  320007     BRA Z, .L5
001796  500FE3     SUB W0, #0x3, [W15]
001798  320008     BRA Z, .L6
00179A  500FE1     SUB W0, #0x1, [W15]
00179C  3A000A     BRA NZ, .L8
933:                       case PWM_GENERATOR_1:
934:                               PDC1 = dutyCycle;                
000E08  90009E     MOV [W14+2], W1
000E0A  886131     MOV W1, PDC1
00179E  90009E     MOV [W14+2], W1
0017A0  886131     MOV W1, PDC1
935:                               break;       
000E0C  370008     BRA .L29
0017A2  370008     BRA .L2
936:                       case PWM_GENERATOR_2:
937:                               PDC2 = dutyCycle;                
000E0E  90009E     MOV [W14+2], W1
000E10  886231     MOV W1, PDC2
0017A4  90009E     MOV [W14+2], W1
0017A6  886231     MOV W1, PDC2
938:                               break;       
000E12  370005     BRA .L29
0017A8  370005     BRA .L2
939:                       case PWM_GENERATOR_3:
940:                               PDC3 = dutyCycle;                
000E14  90009E     MOV [W14+2], W1
000E16  886331     MOV W1, PDC3
0017AA  90009E     MOV [W14+2], W1
0017AC  886331     MOV W1, PDC3
941:                               break;       
000E18  000000     NOP
000E1A  370001     BRA .L29
0017AE  000000     NOP
0017B0  370001     BRA .L2
942:                       default:break;  
000E1C  000000     NOP
0017B2  000000     NOP
943:                   }
944:               }
000E1E  FA8000     ULNK
000E20  060000     RETURN
0017B4  FA8000     ULNK
0017B6  060000     RETURN
945:               
946:               /**
947:                 @Summary
948:                   Sets the PWM period value while in Center-Aligned PWM mode for specific instance.
949:               
950:                 @Description
951:                   This routine is used to disable interrupt request for Special Event Trigger from the Primary time base generator.
952:               
953:                 @Param
954:                   genNum  - PWM generator instance number.
955:                   period  - Period value
956:               
957:                 @Returns
958:                   None
959:                
960:                 @Example 
961:                   <code>    
962:                   PWM_GENERATOR genNum;
963:                   uint16_t period;
964:               
965:                   period = 0x01;
966:                   
967:                   genNum = PWM_GENERATOR_1;
968:                   PWM_PeriodCenterAlignedModeSet(genNum, period);
969:                   </code>
970:               */  
971:               inline static void PWM_PeriodCenterAlignedModeSet(PWM_GENERATOR genNum,uint16_t period)
972:               {
973:                   switch(genNum) { 
974:                       case PWM_GENERATOR_1:
975:                               PHASE1 = period;                
976:                               break;       
977:                       case PWM_GENERATOR_2:
978:                               PHASE2 = period;                
979:                               break;       
980:                       case PWM_GENERATOR_3:
981:                               PHASE3 = period;                
982:                               break;       
983:                       default:break;  
984:                   }
985:               }
986:               
987:               /**
988:                 @Summary
989:                   Sets the PWM deadtime value while in Center-Aligned PWM mode for specific instance.
990:               
991:                 @Description
992:                   This routine is used to set the PWM deadtime value while in Center-Aligned PWM mode for specific instance.
993:               
994:                 @Param
995:                   genNum      - PWM generator instance number.
996:                   deadtime    - Dead time value.
997:               
998:                 @Returns
999:                   None
1000:               
1001:                @Example 
1002:                  <code>    
1003:                  PWM_GENERATOR genNum;
1004:                  uint16_t deadtime;
1005:              
1006:                  deadtime = 0x01;
1007:                  
1008:                  genNum = PWM_GENERATOR_1;
1009:                  PWM_DeadTimeCenterAlignedModeSet(genNum, deadtime);
1010:                  </code>
1011:              */  
1012:              inline static void PWM_DeadTimeCenterAlignedModeSet(PWM_GENERATOR genNum,uint16_t deadtime)
1013:              {
1014:                  switch(genNum) { 
1015:                      case PWM_GENERATOR_1:
1016:                              ALTDTR1 = deadtime;                
1017:                              break;       
1018:                      case PWM_GENERATOR_2:
1019:                              ALTDTR2 = deadtime;                
1020:                              break;       
1021:                      case PWM_GENERATOR_3:
1022:                              ALTDTR3 = deadtime;                
1023:                              break;       
1024:                      default:break;  
1025:                  }
1026:              }
1027:              
1028:              /**
1029:                @Summary
1030:                  Sets the PWM trigger output divider to the desired value for specific instance.
1031:              
1032:                @Description
1033:                  This routine is used to set the PWM trigger output divider to the desired value for specific instance.
1034:              
1035:                @Param
1036:                  genNum          - PWM generator instance number.
1037:                  trigDivValue    - Trigger value.
1038:              
1039:                @Returns
1040:                  None
1041:               
1042:                @Example 
1043:                  <code>    
1044:                  PWM_GENERATOR genNum;
1045:                  uint16_t trigDivValue;
1046:              
1047:                  trigDivValue = 0x01;
1048:                  
1049:                  genNum = PWM_GENERATOR_1;
1050:                  PWM_TriggerDividerSet(genNum, trigDivValue);
1051:                  </code>
1052:              */  
1053:              inline static void PWM_TriggerDividerSet(PWM_GENERATOR genNum,uint16_t trigDivValue)
1054:              {
1055:                  switch(genNum) { 
1056:                      case PWM_GENERATOR_1: 
1057:                              TRGCON1bits.TRGDIV = trigDivValue;               
1058:                              break;       
1059:                      case PWM_GENERATOR_2: 
1060:                              TRGCON2bits.TRGDIV = trigDivValue;               
1061:                              break;       
1062:                      case PWM_GENERATOR_3: 
1063:                              TRGCON3bits.TRGDIV = trigDivValue;               
1064:                              break;       
1065:                      default:break;  
1066:                  }
1067:              }
1068:              
1069:              /**
1070:                @Summary
1071:                  Sets the PWM trigger start delay to the desired value for specific instance.
1072:              
1073:                @Description
1074:                  This routine is used to set the PWM trigger start delay to the desired value for specific instance.
1075:              
1076:                @Param
1077:                  genNum      - PWM generator instance number.
1078:                  delayValue  - Trigger start delay value.
1079:              
1080:                @Returns
1081:                  None
1082:               
1083:                @Example 
1084:                  <code>    
1085:                  PWM_GENERATOR genNum;
1086:                  uint16_t delayValue;
1087:              
1088:                  delayValue = 0x01;
1089:                  
1090:                  genNum = PWM_GENERATOR_1;
1091:                  PWM_TriggerStartDelaySet(genNum, delayValue);
1092:                  </code>
1093:              */  
1094:              inline static void PWM_TriggerStartDelaySet(PWM_GENERATOR genNum,uint16_t delayValue)
1095:              {
1096:                  switch(genNum) { 
1097:                      case PWM_GENERATOR_1: 
1098:                              TRGCON1bits.TRGSTRT = delayValue;               
1099:                              break;       
1100:                      case PWM_GENERATOR_2: 
1101:                              TRGCON2bits.TRGSTRT = delayValue;               
1102:                              break;       
1103:                      case PWM_GENERATOR_3: 
1104:                              TRGCON3bits.TRGSTRT = delayValue;               
1105:                              break;       
1106:                      default:break;  
1107:                  }
1108:              }
1109:              
1110:              /**
1111:                @Summary
1112:                  Sets the PWM trigger compare to the desired value for specific instance.
1113:              
1114:                @Description
1115:                  This routine is used to set the PWM trigger compare to the desired value for specific instance.
1116:              
1117:                @Param
1118:                  genNum          - PWM generator instance number.
1119:                  trigCompValue   - Trigger compare value.
1120:              
1121:                @Returns
1122:                  None
1123:               
1124:                @Example 
1125:                  <code>    
1126:                  PWM_GENERATOR genNum;
1127:                  uint16_t trigCompValue;
1128:              
1129:                  trigCompValue = 0x01;
1130:                  
1131:                  genNum = PWM_GENERATOR_1;
1132:                  PWM_TriggerCompareValueSet(genNum, trigCompValue);
1133:                  </code>
1134:              */  
1135:              inline static void PWM_TriggerCompareValueSet(PWM_GENERATOR genNum,uint16_t trigCompValue)
1136:              {
1137:                  switch(genNum) { 
1138:                      case PWM_GENERATOR_1: 
1139:                              TRIG1 = trigCompValue;               
1140:                              break;       
1141:                      case PWM_GENERATOR_2: 
1142:                              TRIG2 = trigCompValue;               
1143:                              break;       
1144:                      case PWM_GENERATOR_3: 
1145:                              TRIG3 = trigCompValue;               
1146:                              break;       
1147:                      default:break;  
1148:                  }
1149:              }
1150:              
1151:              /**
1152:                @Summary
1153:                  Enables trigger event interrupt requests from specific PWM instance.
1154:              
1155:                @Description
1156:                  This routine is used to enable trigger event interrupt requests from specific PWM instance.
1157:              
1158:                @Param
1159:                  genNum - PWM generator instance number.
1160:              
1161:                @Returns
1162:                  None
1163:               
1164:                @Example 
1165:                  <code>    
1166:                  PWM_GENERATOR genNum;
1167:                  
1168:                  genNum = PWM_GENERATOR_1;
1169:                  PWM_TriggerInterruptEnable(genNum);
1170:                  </code>
1171:              */  
1172:              inline static void PWM_TriggerInterruptEnable(PWM_GENERATOR genNum)
1173:              {	
1174:                   switch(genNum) { 
1175:                      case PWM_GENERATOR_1: 
1176:                              PWMCON1bits.TRGIEN = true;               
1177:                              break;       
1178:                      case PWM_GENERATOR_2: 
1179:                              PWMCON2bits.TRGIEN = true;               
1180:                              break;       
1181:                      case PWM_GENERATOR_3: 
1182:                              PWMCON3bits.TRGIEN = true;               
1183:                              break;       
1184:                      default:break;  
1185:                  }
1186:              }
1187:              
1188:              /**
1189:                @Summary
1190:                  Disables trigger event interrupt requests from specific PWM instance.
1191:              
1192:                @Description
1193:                  This routine is used to disable trigger event interrupt requests from specific PWM instance.
1194:              
1195:                @Param
1196:                  genNum - PWM generator instance number.
1197:              
1198:                @Returns
1199:                  None
1200:               
1201:                @Example 
1202:                  <code>    
1203:                  PWM_GENERATOR genNum;
1204:                  
1205:                  genNum = PWM_GENERATOR_1;
1206:                  PWM_TriggerInterruptDisable(genNum);
1207:                  </code>
1208:              */  
1209:              inline static void PWM_TriggerInterruptDisable(PWM_GENERATOR genNum)
1210:              {	
1211:                   switch(genNum) { 
1212:                      case PWM_GENERATOR_1: 
1213:                              PWMCON1bits.TRGIEN = false;               
1214:                              break;       
1215:                      case PWM_GENERATOR_2: 
1216:                              PWMCON2bits.TRGIEN = false;               
1217:                              break;       
1218:                      case PWM_GENERATOR_3: 
1219:                              PWMCON3bits.TRGIEN = false;               
1220:                              break;       
1221:                      default:break;  
1222:                  }
1223:              }
1224:              
1225:              /**
1226:                @Summary
1227:                  Enables current limit interrupt requests from specific PWM instance.
1228:              
1229:                @Description
1230:                  This routine is used to enable current limit interrupt requests from specific PWM instance.
1231:              
1232:                @Param
1233:                  genNum - PWM generator instance number.
1234:              
1235:                @Returns
1236:                  None
1237:               
1238:                @Example 
1239:                  <code>    
1240:                  PWM_GENERATOR genNum;
1241:                  
1242:                  genNum = PWM_GENERATOR_1;
1243:                  PWM_CurrentLimitInterruptEnable(genNum);
1244:                  </code>
1245:              */  
1246:              inline static void PWM_CurrentLimitInterruptEnable(PWM_GENERATOR genNum)
1247:              {	
1248:                  switch(genNum) { 
1249:                      case PWM_GENERATOR_1: 
1250:                              PWMCON1bits.CLIEN = true;               
1251:                              break;       
1252:                      case PWM_GENERATOR_2: 
1253:                              PWMCON2bits.CLIEN = true;               
1254:                              break;       
1255:                      case PWM_GENERATOR_3: 
1256:                              PWMCON3bits.CLIEN = true;               
1257:                              break;       
1258:                      default:break;  
1259:                  }
1260:              }
1261:              
1262:              /**
1263:                @Summary
1264:                  Disables current limit interrupt requests from specific PWM instance.
1265:              
1266:                @Description
1267:                  This routine is used to disable current limit interrupt requests from specific PWM instance.
1268:              
1269:                @Param
1270:                  genNum - PWM generator instance number.
1271:              
1272:                @Returns
1273:                  None
1274:               
1275:                @Example 
1276:                  <code>    
1277:                  PWM_GENERATOR genNum;
1278:                  
1279:                  genNum = PWM_GENERATOR_1;
1280:                  PWM_CurrentLimitInterruptDisable(genNum);
1281:                  </code>
1282:              */  
1283:              inline static void PWM_CurrentLimitInterruptDisable(PWM_GENERATOR genNum)
1284:              {	
1285:                   switch(genNum) { 
1286:                      case PWM_GENERATOR_1: 
1287:                              PWMCON1bits.CLIEN = false;               
1288:                              break;       
1289:                      case PWM_GENERATOR_2: 
1290:                              PWMCON2bits.CLIEN = false;               
1291:                              break;       
1292:                      case PWM_GENERATOR_3: 
1293:                              PWMCON3bits.CLIEN = false;               
1294:                              break;       
1295:                      default:break;  
1296:                  }
1297:              }
1298:              
1299:              /**
1300:                @Summary
1301:                  Enables fault event interrupt requests from specific PWM instance.
1302:              
1303:                @Description
1304:                  This routine is used to enable fault event interrupt requests from specific PWM instance.
1305:              
1306:                @Param
1307:                  genNum - PWM generator instance number.
1308:              
1309:                @Returns
1310:                  None
1311:               
1312:                @Example 
1313:                  <code>    
1314:                  PWM_GENERATOR genNum;
1315:                  
1316:                  genNum = PWM_GENERATOR_1;
1317:                  PWM_FaultInterruptEnable(genNum);
1318:                  </code>
1319:              */  
1320:              inline static void PWM_FaultInterruptEnable(PWM_GENERATOR genNum)
1321:              {	
1322:                  switch(genNum) { 
1323:                      case PWM_GENERATOR_1: 
1324:                              PWMCON1bits.FLTIEN = true;               
1325:                              break;       
1326:                      case PWM_GENERATOR_2: 
1327:                              PWMCON2bits.FLTIEN = true;               
1328:                              break;       
1329:                      case PWM_GENERATOR_3: 
1330:                              PWMCON3bits.FLTIEN = true;               
1331:                              break;       
1332:                      default:break;  
1333:                  } 
1334:              }
1335:              
1336:              /**
1337:                @Summary
1338:                  Disables fault event interrupt requests from specific PWM instance.
1339:              
1340:                @Description
1341:                  This routine is used to disable fault event interrupt requests from specific PWM instance.
1342:              
1343:                @Param
1344:                  genNum - PWM generator instance number.
1345:              
1346:                @Returns
1347:                  None
1348:               
1349:                @Example 
1350:                  <code>    
1351:                  PWM_GENERATOR genNum;
1352:                  
1353:                  genNum = PWM_GENERATOR_1;
1354:                  PWM_FaultInterruptDisable(genNum);
1355:                  </code>
1356:              */  
1357:              inline static void PWM_FaultInterruptDisable(PWM_GENERATOR genNum)
1358:              {	
1359:                  switch(genNum) { 
1360:                      case PWM_GENERATOR_1: 
1361:                              PWMCON1bits.FLTIEN = false;               
1362:                              break;       
1363:                      case PWM_GENERATOR_2: 
1364:                              PWMCON2bits.FLTIEN = false;               
1365:                              break;       
1366:                      case PWM_GENERATOR_3: 
1367:                              PWMCON3bits.FLTIEN = false;               
1368:                              break;       
1369:                      default:break;  
1370:                  }
1371:              }
1372:              
1373:              /**
1374:                @Summary
1375:                  Callback for PWM Special Event.
1376:              
1377:                @Description
1378:                  This routine is callback for PWM Special Event
1379:              
1380:                @Param
1381:                  None.
1382:              
1383:                @Returns
1384:                  None
1385:               
1386:                @Example 
1387:              	Refer to PWM_Initialize(); for an example
1388:              */
1389:              void PWM_SpecialEvent_CallBack(void);
1390:              
1391:              /**
1392:                @Summary
1393:                  Polled implementation
1394:              
1395:                @Description
1396:                  This routine is used to implement the tasks for polled implementations.
1397:                
1398:                @Preconditions
1399:                  PWM_Initialize() function should have been 
1400:                  called before calling this function.
1401:               
1402:                @Returns 
1403:                  None
1404:               
1405:                @Param
1406:                  None
1407:               
1408:                @Example
1409:                  Refer to PWM_Initialize(); for an example
1410:                  
1411:              */
1412:              void PWM_SpecialEvent_Tasks(void);
1413:              
1414:              /**
1415:                @Summary
1416:                  Callback for PWM Generator1.
1417:              
1418:                @Description
1419:                  This routine is callback for PWM Generator1
1420:              
1421:                @Param
1422:                  None.
1423:              
1424:                @Returns
1425:                  None
1426:               
1427:                @Example 
1428:              	Refer to PWM_Initialize(); for an example
1429:              */
1430:              void PWM_Generator1_CallBack(void);
1431:              
1432:              /**
1433:                @Summary
1434:                  Polled implementation
1435:              
1436:                @Description
1437:                  This routine is used to implement the tasks for polled implementations.
1438:                
1439:                @Preconditions
1440:                  PWM_Initialize() function should have been 
1441:                  called before calling this function.
1442:               
1443:                @Returns 
1444:                  None
1445:               
1446:                @Param
1447:                  None
1448:               
1449:                @Example
1450:                  Refer to PWM_Initialize(); for an example
1451:                  
1452:              */
1453:              void PWM_Generator1_Tasks(void);
1454:              /**
1455:                @Summary
1456:                  Callback for PWM Generator2.
1457:              
1458:                @Description
1459:                  This routine is callback for PWM Generator2
1460:              
1461:                @Param
1462:                  None.
1463:              
1464:                @Returns
1465:                  None
1466:               
1467:                @Example 
1468:              	Refer to PWM_Initialize(); for an example
1469:              */
1470:              void PWM_Generator2_CallBack(void);
1471:              
1472:              /**
1473:                @Summary
1474:                  Polled implementation
1475:              
1476:                @Description
1477:                  This routine is used to implement the tasks for polled implementations.
1478:                
1479:                @Preconditions
1480:                  PWM_Initialize() function should have been 
1481:                  called before calling this function.
1482:               
1483:                @Returns 
1484:                  None
1485:               
1486:                @Param
1487:                  None
1488:               
1489:                @Example
1490:                  Refer to PWM_Initialize(); for an example
1491:                  
1492:              */
1493:              void PWM_Generator2_Tasks(void);
1494:              /**
1495:                @Summary
1496:                  Callback for PWM Generator3.
1497:              
1498:                @Description
1499:                  This routine is callback for PWM Generator3
1500:              
1501:                @Param
1502:                  None.
1503:              
1504:                @Returns
1505:                  None
1506:               
1507:                @Example 
1508:              	Refer to PWM_Initialize(); for an example
1509:              */
1510:              void PWM_Generator3_CallBack(void);
1511:              
1512:              /**
1513:                @Summary
1514:                  Polled implementation
1515:              
1516:                @Description
1517:                  This routine is used to implement the tasks for polled implementations.
1518:                
1519:                @Preconditions
1520:                  PWM_Initialize() function should have been 
1521:                  called before calling this function.
1522:               
1523:                @Returns 
1524:                  None
1525:               
1526:                @Param
1527:                  None
1528:               
1529:                @Example
1530:                  Refer to PWM_Initialize(); for an example
1531:                  
1532:              */
1533:              void PWM_Generator3_Tasks(void);
1534:              
1535:              #ifdef __cplusplus  // Provide C++ Compatibility
1536:              
1537:                  }
1538:              
1539:              #endif
1540:              
1541:              #endif //_PWM_H
1542:                  
1543:              /**
1544:               End of File
1545:              */
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/pwm.c  ---------------
1:                 /**
2:                   PWM Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     pwm.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the PWM driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This source file provides APIs for PWM.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
17:                        Device            :  dsPIC33EP128MC504      
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.35
20:                        MPLAB 	          :  MPLAB X v5.05
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                
49:                #include <xc.h>
50:                #include "pwm.h"
51:                
52:                /**
53:                  Section: Driver Interface
54:                */
55:                
56:                
57:                void PWM_Initialize (void)
58:                {
0013A2  FA0000     LNK #0x0
59:                    // PCLKDIV 1; 
60:                    PTCON2 = 0x00;
0013A4  EF2C02     CLR PTCON2
61:                    // PTPER 1919; 
62:                    PTPER = 0x77F;
0013A6  2077F0     MOV #0x77F, W0
0013A8  886020     MOV W0, PTPER
63:                    // SEVTCMP 0; 
64:                    SEVTCMP = 0x00;
0013AA  EF2C06     CLR SEVTCMP
65:                    // MDC 36864; 
66:                    MDC = 0x9000;
0013AC  290000     MOV #0x9000, W0
0013AE  886050     MOV W0, MDC
67:                    // CHOPCLK 0; CHPCLKEN disabled; 
68:                    CHOP = 0x00;
0013B0  EF2C1A     CLR CHOP
69:                    // PWMKEY 0; 
70:                    PWMKEY = 0x00;
0013B2  EF2C1E     CLR PWMKEY
71:                    // MDCS Primary; FLTIEN disabled; CAM Edge Aligned; DTC Dead-time function is disabled; TRGIEN disabled; XPRES disabled; ITB Master; IUE disabled; CLIEN disabled; MTBS disabled; DTCP disabled; 
72:                    PWMCON1 = 0x80;
0013B4  200800     MOV #0x80, W0
0013B6  886100     MOV W0, PWMCON1
73:                    // MDCS Primary; FLTIEN disabled; CAM Edge Aligned; DTC Dead-time function is disabled; TRGIEN disabled; XPRES disabled; ITB Master; IUE disabled; CLIEN disabled; MTBS disabled; DTCP disabled; 
74:                    PWMCON2 = 0x80;
0013B8  200800     MOV #0x80, W0
0013BA  886200     MOV W0, PWMCON2
75:                    // MDCS Primary; FLTIEN disabled; CAM Edge Aligned; DTC Dead-time function is disabled; TRGIEN disabled; XPRES disabled; ITB Master; IUE disabled; CLIEN disabled; MTBS disabled; DTCP disabled; 
76:                    PWMCON3 = 0x80;
0013BC  200800     MOV #0x80, W0
0013BE  886300     MOV W0, PWMCON3
77:                    //FLTDAT PWM1L Low, PWM1H Low; SWAP disabled; OVRENH enabled; PENL enabled; PMOD Redundant Output Mode; OVRENL enabled; OSYNC disabled; POLL disabled; PENH enabled; CLDAT PWM1L Low, PWM1H Low; OVRDAT PWM1L Low, PWM1H Low; POLH disabled; 
78:                    __builtin_write_PWMSFR(&IOCON1, 0xC700, &PWMKEY);
0013C0  2C7000     MOV #0xC700, W0
0013C2  20C1E3     MOV #0xC1E, W3
0013C4  243211     MOV #0x4321, W1
0013C6  2ABCD2     MOV #0xABCD, W2
0013C8  780982     MOV W2, [W3]
0013CA  780981     MOV W1, [W3]
0013CC  886110     MOV W0, IOCON1
79:                    //FLTDAT PWM2L Low, PWM2H Low; SWAP disabled; OVRENH disabled; PENL disabled; PMOD Complementary Output Mode; OVRENL disabled; OSYNC disabled; POLL disabled; PENH disabled; CLDAT PWM2L Low, PWM2H Low; OVRDAT PWM2L Low, PWM2H Low; POLH disabled; 
80:                    __builtin_write_PWMSFR(&IOCON2, 0x00, &PWMKEY);
0013CE  EB0000     CLR W0
0013D0  20C1E3     MOV #0xC1E, W3
0013D2  243211     MOV #0x4321, W1
0013D4  2ABCD2     MOV #0xABCD, W2
0013D6  780982     MOV W2, [W3]
0013D8  780981     MOV W1, [W3]
0013DA  886210     MOV W0, IOCON2
81:                    //FLTDAT PWM3L Low, PWM3H Low; SWAP disabled; OVRENH disabled; PENL disabled; PMOD Complementary Output Mode; OVRENL disabled; OSYNC disabled; POLL disabled; PENH disabled; CLDAT PWM3L Low, PWM3H Low; OVRDAT PWM3L Low, PWM3H Low; POLH disabled; 
82:                    __builtin_write_PWMSFR(&IOCON3, 0x00, &PWMKEY);
0013DC  EB0000     CLR W0
0013DE  20C1E3     MOV #0xC1E, W3
0013E0  243211     MOV #0x4321, W1
0013E2  2ABCD2     MOV #0xABCD, W2
0013E4  780982     MOV W2, [W3]
0013E6  780981     MOV W1, [W3]
0013E8  886310     MOV W0, IOCON3
83:                    //FLTPOL disabled; CLPOL disabled; CLSRC FLT1; CLMOD disabled; FLTMOD Fault input is disabled; FLTSRC FLT1; 
84:                    __builtin_write_PWMSFR(&FCLCON1, 0x03, &PWMKEY);
0013EA  200030     MOV #0x3, W0
0013EC  20C1E3     MOV #0xC1E, W3
0013EE  243211     MOV #0x4321, W1
0013F0  2ABCD2     MOV #0xABCD, W2
0013F2  780982     MOV W2, [W3]
0013F4  780981     MOV W1, [W3]
0013F6  886120     MOV W0, FCLCON1
85:                    //FLTPOL disabled; CLPOL disabled; CLSRC FLT1; CLMOD disabled; FLTMOD Fault input is disabled; FLTSRC FLT1; 
86:                    __builtin_write_PWMSFR(&FCLCON2, 0x03, &PWMKEY);
0013F8  200030     MOV #0x3, W0
0013FA  20C1E3     MOV #0xC1E, W3
0013FC  243211     MOV #0x4321, W1
0013FE  2ABCD2     MOV #0xABCD, W2
001400  780982     MOV W2, [W3]
001402  780981     MOV W1, [W3]
001404  886220     MOV W0, FCLCON2
87:                    //FLTPOL disabled; CLPOL disabled; CLSRC FLT1; CLMOD disabled; FLTMOD Fault input is disabled; FLTSRC FLT1; 
88:                    __builtin_write_PWMSFR(&FCLCON3, 0x03, &PWMKEY);
001406  200030     MOV #0x3, W0
001408  20C1E3     MOV #0xC1E, W3
00140A  243211     MOV #0x4321, W1
00140C  2ABCD2     MOV #0xABCD, W2
00140E  780982     MOV W2, [W3]
001410  780981     MOV W1, [W3]
001412  886320     MOV W0, FCLCON3
89:                    // PDC1 1280; 
90:                    PDC1 = 0x500;
001414  205000     MOV #0x500, W0
001416  886130     MOV W0, PDC1
91:                    // PDC2 0; 
92:                    PDC2 = 0x00;
001418  EF2C46     CLR PDC2
93:                    // PDC3 0; 
94:                    PDC3 = 0x00;
00141A  EF2C66     CLR PDC3
95:                    // PHASE1 0; 
96:                    PHASE1 = 0x00;
00141C  EF2C28     CLR PHASE1
97:                    // PHASE2 0; 
98:                    PHASE2 = 0x00;
00141E  EF2C48     CLR PHASE2
99:                    // PHASE3 0; 
100:                   PHASE3 = 0x00;
001420  EF2C68     CLR PHASE3
101:                   // DTR1 0; 
102:                   DTR1 = 0x00;
001422  EF2C2A     CLR DTR1
103:                   // DTR2 0; 
104:                   DTR2 = 0x00;
001424  EF2C4A     CLR DTR2
105:                   // DTR3 0; 
106:                   DTR3 = 0x00;
001426  EF2C6A     CLR DTR3
107:                   // ALTDTR1 0; 
108:                   ALTDTR1 = 0x00;
001428  EF2C2C     CLR ALTDTR1
109:                   // ALTDTR2 0; 
110:                   ALTDTR2 = 0x00;
00142A  EF2C4C     CLR ALTDTR2
111:                   // ALTDTR3 0; 
112:                   ALTDTR3 = 0x00;
00142C  EF2C6C     CLR ALTDTR3
113:                   // TRGCMP 127; 
114:                   TRIG1 = 0x3F8;
00142E  203F80     MOV #0x3F8, W0
001430  886190     MOV W0, TRIG1
115:                   // TRGCMP 0; 
116:                   TRIG2 = 0x00;
001432  EF2C52     CLR TRIG2
117:                   // TRGCMP 0; 
118:                   TRIG3 = 0x00;
001434  EF2C72     CLR TRIG3
119:                   // TRGDIV 1; TRGSTRT 0; 
120:                   TRGCON1 = 0x00;
001436  EF2C34     CLR TRGCON1
121:                   // TRGDIV 1; TRGSTRT 0; 
122:                   TRGCON2 = 0x00;
001438  EF2C54     CLR TRGCON2
123:                   // TRGDIV 1; TRGSTRT 0; 
124:                   TRGCON3 = 0x00;
00143A  EF2C74     CLR TRGCON3
125:                   // BPLL disabled; BPHH disabled; BPLH disabled; BCH disabled; FLTLEBEN disabled; PLR disabled; CLLEBEN disabled; BCL disabled; PLF disabled; PHR disabled; BPHL disabled; PHF disabled; 
126:                   LEBCON1 = 0x00;
00143C  EF2C3A     CLR LEBCON1
127:                   // BPLL disabled; BPHH disabled; BPLH disabled; BCH disabled; FLTLEBEN disabled; PLR disabled; CLLEBEN disabled; BCL disabled; PLF disabled; PHR disabled; BPHL disabled; PHF disabled; 
128:                   LEBCON2 = 0x00;
00143E  EF2C5A     CLR LEBCON2
129:                   // BPLL disabled; BPHH disabled; BPLH disabled; BCH disabled; FLTLEBEN disabled; PLR disabled; CLLEBEN disabled; BCL disabled; PLF disabled; PHR disabled; BPHL disabled; PHF disabled; 
130:                   LEBCON3 = 0x00;
001440  EF2C7A     CLR LEBCON3
131:                   // LEB 0; 
132:                   LEBDLY1 = 0x00;
001442  EF2C3C     CLR LEBDLY1
133:                   // LEB 0; 
134:                   LEBDLY2 = 0x00;
001444  EF2C5C     CLR LEBDLY2
135:                   // LEB 0; 
136:                   LEBDLY3 = 0x00;
001446  EF2C7C     CLR LEBDLY3
137:                   // CHOPLEN disabled; CHOPHEN disabled; BLANKSEL No state blanking; CHOPSEL No state blanking; 
138:                   AUXCON1 = 0x00;
001448  EF2C3E     CLR AUXCON1
139:                   // CHOPLEN disabled; CHOPHEN disabled; BLANKSEL No state blanking; CHOPSEL No state blanking; 
140:                   AUXCON2 = 0x00;
00144A  EF2C5E     CLR AUXCON2
141:                   // CHOPLEN disabled; CHOPHEN disabled; BLANKSEL No state blanking; CHOPSEL No state blanking; 
142:                   AUXCON3 = 0x00;
00144C  EF2C7E     CLR AUXCON3
143:                   
144:               
145:                   // SYNCOEN disabled; SEIEN disabled; SESTAT disabled; SEVTPS 1; SYNCSRC SYNCI1; SYNCEN disabled; PTSIDL disabled; PTEN enabled; EIPU disabled; SYNCPOL disabled; 
146:                   PTCON = 0x8000;
00144E  280000     MOV #0x8000, W0
001450  886000     MOV W0, PTCON
147:               }
001452  FA8000     ULNK
001454  060000     RETURN
148:               
149:               void __attribute__ ((weak)) PWM_SpecialEvent_CallBack(void)
150:               {
001456  FA0000     LNK #0x0
151:                   // Add your custom callback code here
152:               }
001458  FA8000     ULNK
00145A  060000     RETURN
153:               
154:               void PWM_SpecialEvent_Tasks ( void )
155:               {
00145C  FA0000     LNK #0x0
156:               	if(IFS3bits.PSEMIF)
00145E  804031     MOV IFS3, W1
001460  202000     MOV #0x200, W0
001462  608000     AND W1, W0, W0
001464  E00000     CP0 W0
001466  320002     BRA Z, .L3
157:               	{
158:               		// PWM SpecialEvent callback function 
159:               		PWM_SpecialEvent_CallBack();
001468  07FFF6     RCALL PWM_SpecialEvent_CallBack
160:               		
161:               		// clear the PWM SpecialEvent interrupt flag
162:               		IFS3bits.PSEMIF = 0;
00146A  A92807     BCLR 0x807, #1
163:               	}
164:               }
00146C  FA8000     ULNK
00146E  060000     RETURN
165:               
166:               void __attribute__ ((weak)) PWM_Generator1_CallBack(void)
167:               {
001470  FA0000     LNK #0x0
168:                   // Add your custom callback code here
169:               }
001472  FA8000     ULNK
001474  060000     RETURN
170:               
171:               void PWM_Generator1_Tasks ( void )
172:               {
001476  FA0000     LNK #0x0
173:               	if(IFS3bits.PSEMIF)
001478  804031     MOV IFS3, W1
00147A  202000     MOV #0x200, W0
00147C  608000     AND W1, W0, W0
00147E  E00000     CP0 W0
001480  320002     BRA Z, .L6
174:               	{
175:               		// PWM Generator1 callback function 
176:               		PWM_Generator1_CallBack();
001482  07FFF6     RCALL PWM_Generator1_CallBack
177:               		
178:               		// clear the PWM Generator1 interrupt flag
179:               		IFS5bits.PWM1IF = 0;
001484  A9C80B     BCLR 0x80B, #6
180:               	}
181:               }
001486  FA8000     ULNK
001488  060000     RETURN
182:               void __attribute__ ((weak)) PWM_Generator2_CallBack(void)
183:               {
00148A  FA0000     LNK #0x0
184:                   // Add your custom callback code here
185:               }
00148C  FA8000     ULNK
00148E  060000     RETURN
186:               
187:               void PWM_Generator2_Tasks ( void )
188:               {
001490  FA0000     LNK #0x0
189:               	if(IFS3bits.PSEMIF)
001492  804031     MOV IFS3, W1
001494  202000     MOV #0x200, W0
001496  608000     AND W1, W0, W0
001498  E00000     CP0 W0
00149A  320002     BRA Z, .L9
190:               	{
191:               		// PWM Generator2 callback function 
192:               		PWM_Generator2_CallBack();
00149C  07FFF6     RCALL PWM_Generator2_CallBack
193:               		
194:               		// clear the PWM Generator2 interrupt flag
195:               		IFS5bits.PWM2IF = 0;
00149E  A9E80B     BCLR 0x80B, #7
196:               	}
197:               }
0014A0  FA8000     ULNK
0014A2  060000     RETURN
198:               void __attribute__ ((weak)) PWM_Generator3_CallBack(void)
199:               {
0014A4  FA0000     LNK #0x0
200:                   // Add your custom callback code here
201:               }
0014A6  FA8000     ULNK
0014A8  060000     RETURN
202:               
203:               void PWM_Generator3_Tasks ( void )
204:               {
0014AA  FA0000     LNK #0x0
205:               	if(IFS3bits.PSEMIF)
0014AC  804031     MOV IFS3, W1
0014AE  202000     MOV #0x200, W0
0014B0  608000     AND W1, W0, W0
0014B2  E00000     CP0 W0
0014B4  320002     BRA Z, .L12
206:               	{
207:               		// PWM Generator3 callback function 
208:               		PWM_Generator3_CallBack();
0014B6  07FFF6     RCALL PWM_Generator3_CallBack
209:               		
210:               		// clear the PWM Generator3 interrupt flag
211:               		IFS6bits.PWM3IF = 0;
0014B8  A9080C     BCLR IFS6, #0
212:               	}
213:               }
0014BA  FA8000     ULNK
0014BC  060000     RETURN
214:               
215:               /**
216:                End of File
217:               */
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/pin_manager.c  -------
1:                 /**
2:                   PIN MANAGER Generated Driver File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     pin_manager.c
9:                 
10:                  @Summary:
11:                    This is the generated manager file for the PIC24 / dsPIC33 / PIC32MM MCUs device.  This manager
12:                    configures the pins direction, initial state, analog setting.
13:                    The peripheral pin select, PPS, configuration is also handled by this manager.
14:                
15:                  @Description:
16:                    This source file provides implementations for PIN MANAGER.
17:                    Generation Information :
18:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
19:                        Device            :  dsPIC33EP128MC504
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 v1.35
22:                        MPLAB 	          :  MPLAB X v5.05
23:                */
24:                
25:                /*
26:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
27:                    software and any derivatives exclusively with Microchip products.
28:                
29:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
33:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
34:                
35:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:                
43:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
44:                    TERMS.
45:                */
46:                
47:                
48:                /**
49:                    Section: Includes
50:                */
51:                
52:                #include <xc.h>
53:                #include "pin_manager.h"
54:                
55:                /**
56:                 Section: Driver Interface Function Definitions
57:                */
58:                void PIN_MANAGER_Initialize (void)
59:                {
001A08  FA0000     LNK #0x0
60:                    /****************************************************************************
61:                     * Setting the Output Latch SFR(s)
62:                     ***************************************************************************/
63:                    LATA = 0x0000;
001A0A  EF2E04     CLR LATA
64:                    LATB = 0x0000;
001A0C  EF2E14     CLR LATB
65:                    LATC = 0x0000;
001A0E  EF2E24     CLR LATC
66:                
67:                    /****************************************************************************
68:                     * Setting the GPIO Direction SFR(s)
69:                     ***************************************************************************/
70:                    TRISA = 0x0313;
001A10  203130     MOV #0x313, W0
001A12  887000     MOV W0, TRISA
71:                    TRISB = 0x03F9;
001A14  203F90     MOV #0x3F9, W0
001A16  887080     MOV W0, TRISB
72:                    TRISC = 0x01F1;
001A18  201F10     MOV #0x1F1, W0
001A1A  887100     MOV W0, TRISC
73:                
74:                    /****************************************************************************
75:                     * Setting the Weak Pull Up and Weak Pull Down SFR(s)
76:                     ***************************************************************************/
77:                    CNPDA = 0x0000;
001A1C  EF2E0C     CLR CNPDA
78:                    CNPDB = 0x0000;
001A1E  EF2E1C     CLR CNPDB
79:                    CNPDC = 0x0000;
001A20  EF2E2C     CLR CNPDC
80:                    CNPUA = 0x0000;
001A22  EF2E0A     CLR CNPUA
81:                    CNPUB = 0x0000;
001A24  EF2E1A     CLR CNPUB
82:                    CNPUC = 0x0000;
001A26  EF2E2A     CLR CNPUC
83:                
84:                    /****************************************************************************
85:                     * Setting the Open Drain SFR(s)
86:                     ***************************************************************************/
87:                    ODCA = 0x0000;
001A28  EF2E06     CLR ODCA
88:                    ODCB = 0x0000;
001A2A  EF2E16     CLR ODCB
89:                    ODCC = 0x0000;
001A2C  EF2E26     CLR ODCC
90:                
91:                    /****************************************************************************
92:                     * Setting the Analog/Digital Configuration SFR(s)
93:                     ***************************************************************************/
94:                    ANSELA = 0x0003;
001A2E  200030     MOV #0x3, W0
001A30  887070     MOV W0, ANSELA
95:                    ANSELB = 0x000F;
001A32  2000F0     MOV #0xF, W0
001A34  8870F0     MOV W0, ANSELB
96:                    ANSELC = 0x0003;
001A36  200030     MOV #0x3, W0
001A38  887170     MOV W0, ANSELC
97:                
98:                
99:                
100:               }
001A3A  FA8000     ULNK
001A3C  060000     RETURN
101:               
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/mcc.c  ---------------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     mcc.c
9:                 
10:                  @Summary:
11:                    This is the mcc.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
17:                        Device            :  dsPIC33EP128MC504
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.35
20:                        MPLAB             :  MPLAB X v5.05
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                // Configuration bits: selected in the GUI
46:                
47:                // FICD
48:                #pragma config ICS = PGD2    //ICD Communication Channel Select bits->Communicate on PGEC2 and PGED2
49:                #pragma config JTAGEN = OFF    //JTAG Enable bit->JTAG is disabled
50:                
51:                // FPOR
52:                #pragma config ALTI2C1 = OFF    //Alternate I2C1 pins->I2C1 mapped to SDA1/SCL1 pins
53:                #pragma config ALTI2C2 = OFF    //Alternate I2C2 pins->I2C2 mapped to SDA2/SCL2 pins
54:                #pragma config WDTWIN = WIN25    //Watchdog Window Select bits->WDT Window is 25% of WDT period
55:                
56:                // FWDT
57:                #pragma config WDTPOST = PS32768    //Watchdog Timer Postscaler bits->1:32768
58:                #pragma config WDTPRE = PR128    //Watchdog Timer Prescaler bit->1:128
59:                #pragma config PLLKEN = ON    //PLL Lock Enable bit->Clock switch to PLL source will wait until the PLL lock signal is valid.
60:                #pragma config WINDIS = OFF    //Watchdog Timer Window Enable bit->Watchdog Timer in Non-Window mode
61:                #pragma config FWDTEN = OFF    //Watchdog Timer Enable bit->Watchdog timer enabled/disabled by user software
62:                
63:                // FOSC
64:                #pragma config POSCMD = NONE    //Primary Oscillator Mode Select bits->Primary Oscillator disabled
65:                #pragma config OSCIOFNC = ON    //OSC2 Pin Function bit->OSC2 is general purpose digital I/O pin
66:                #pragma config IOL1WAY = ON    //Peripheral pin select configuration->Allow only one reconfiguration
67:                #pragma config FCKSM = CSECMD    //Clock Switching Mode bits->Clock switching is enabled,Fail-safe Clock Monitor is disabled
68:                
69:                // FOSCSEL
70:                #pragma config FNOSC = FRC    //Oscillator Source Selection->FRC
71:                #pragma config PWMLOCK = ON    //PWM Lock Enable bit->Certain PWM registers may only be written after key sequence
72:                #pragma config IESO = ON    //Two-speed Oscillator Start-up Enable bit->Start up device with FRC, then switch to user-selected oscillator source
73:                
74:                // FGS
75:                #pragma config GWRP = OFF    //General Segment Write-Protect bit->General Segment may be written
76:                #pragma config GCP = OFF    //General Segment Code-Protect bit->General Segment Code protect is Disabled
77:                
78:                #include "mcc.h"
79:                #include "reset.h"
80:                #include "clock.h"
81:                
82:                /**
83:                 Section: Local Variables
84:                */
85:                
86:                /**
87:                 Section: Function prototypes
88:                */
89:                
90:                /**
91:                * a private place to store the error code if we run into a severe error
92:                */
93:                
94:                void OSCILLATOR_Initialize(void)
95:                {
001A62  FA0000     LNK #0x0
96:                    CLOCK_Initialize();
001A64  07FF6B     RCALL CLOCK_Initialize
97:                }
001A66  FA8000     ULNK
001A68  060000     RETURN
98:                
99:                uint16_t SYSTEM_GetResetCause(void)
100:               {
001A6A  FA0000     LNK #0x0
101:                   return RCON;
001A6C  803A00     MOV RCON, W0
102:               }
001A6E  FA8000     ULNK
001A70  060000     RETURN
103:               
104:               void __attribute__ ((weak)) SYSTEM_ResetCauseHandler(void)
105:               {
001A72  FA0000     LNK #0x0
106:                   RESET_CauseHandler();
001A74  07FD28     RCALL RESET_CauseHandler
107:               }
001A76  FA8000     ULNK
001A78  060000     RETURN
108:               
109:               void SYSTEM_ResetCauseClearAll()
110:               { 
001A7A  FA0000     LNK #0x0
111:                   RESET_CauseClearAll();
001A7C  07FDA6     RCALL RESET_CauseClearAll
112:               }
001A7E  FA8000     ULNK
001A80  060000     RETURN
113:               /**
114:                End of File
115:               */
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/interrupt_manager.h  -
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
18:                        Device            :  dsPIC33EP128MC504
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.35
21:                        MPLAB             :  MPLAB X v5.05
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #ifndef _INTERRUPT_MANAGER_H
46:                #define _INTERRUPT_MANAGER_H
47:                
48:                /**
49:                  @Summary
50:                    Initializes the interrupt priorities of the dsPIC33EP128MC504
51:                
52:                  @Description
53:                    This routine sets the interrupt priorities of the modules that have been configured
54:                    for the dsPIC33EP128MC504
55:                
56:                  @Preconditions
57:                    None.
58:                
59:                  @Returns
60:                    None.
61:                
62:                  @Param
63:                    None.
64:                
65:                  @Example
66:                    <code>
67:                    void SYSTEM_Initialize(void)
68:                    {
69:                        // Other initializers are called from this function
70:                        INTERRUPT_Initialize ();
71:                    }
72:                    </code>
73:                
74:                */
75:                void INTERRUPT_Initialize(void);
76:                
77:                /**
78:                  @Summary
79:                    Enables global interrupts of the dsPIC33EP128MC504
80:                
81:                  @Description
82:                    This routine enables the global interrupt bit for the dsPIC33EP128MC504
83:                
84:                  @Preconditions
85:                    None.
86:                
87:                  @Returns
88:                    None.
89:                
90:                  @Param
91:                    None.
92:                
93:                  @Example
94:                    <code>
95:                    void SYSTEM_Initialize(void)
96:                    {
97:                        // Other initializers are called from this function
98:                        INTERRUPT_GlobalEnable ();
99:                    }
100:                   </code>
101:               
102:               */
103:               inline static void INTERRUPT_GlobalEnable(void)
104:               {
0019E4  FA0000     LNK #0x0
105:                   __builtin_enable_interrupts();
0019E6  A8E8C3     BSET 0x8C3, #7
0019E8  000000     NOP
0019EA  000000     NOP
106:               }
0019EC  FA8000     ULNK
0019EE  060000     RETURN
107:               
108:               /**
109:                 @Summary
110:                   Disables global interrupts of the dsPIC33EP128MC504
111:               
112:                 @Description
113:                   This routine disables the global interrupt bit for the dsPIC33EP128MC504
114:               
115:                 @Preconditions
116:                   None.
117:               
118:                 @Returns
119:                   None.
120:               
121:                 @Param
122:                   None.
123:               
124:                 @Example
125:                   <code>
126:                   void SYSTEM_Initialize(void)
127:                   {
128:                       // Other initializers are called from this function
129:                       INTERRUPT_GlobalDisable ();
130:                   }
131:                   </code>
132:               
133:               */
134:               inline static void INTERRUPT_GlobalDisable(void)
135:               {
136:                   __builtin_disable_interrupts();
137:               }
138:               
139:               
140:               #endif
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/interrupt_manager.c  -
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
18:                        Device            :  dsPIC33EP128MC504
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.35
21:                        MPLAB             :  MPLAB X v5.05
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                
50:                /**
51:                    void INTERRUPT_Initialize (void)
52:                */
53:                void INTERRUPT_Initialize (void)
54:                {
001A3E  FA0000     LNK #0x0
55:                    //    MICI: I2C1 Master Events
56:                    //    Priority: 1
57:                        IPC4bits.MI2C1IP = 1;
001A40  804241     MOV IPC4, W1
001A42  2FF8F0     MOV #0xFF8F, W0
001A44  608000     AND W1, W0, W0
001A46  A04000     BSET W0, #4
001A48  884240     MOV W0, IPC4
58:                        
59:                     //    ADI: ADC1 Convert Done
60:                    //    Priority: 1
61:                        IPC3bits.AD1IP = 1;           
001A4A  804231     MOV IPC3, W1
001A4C  2FF8F0     MOV #0xFF8F, W0
001A4E  608000     AND W1, W0, W0
001A50  A04000     BSET W0, #4
001A52  884230     MOV W0, IPC3
62:                        
63:                    //    TI: Timer 5
64:                    //    Priority: 1
65:                        IPC7bits.T5IP = 1;    
001A54  804271     MOV IPC7, W1
001A56  2FFF80     MOV #0xFFF8, W0
001A58  608000     AND W1, W0, W0
001A5A  A00000     BSET W0, #0
001A5C  884270     MOV W0, IPC7
66:                }
001A5E  FA8000     ULNK
001A60  060000     RETURN
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/mcc_generated_files/clock.c  -------------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     clock.c
9:                 
10:                  @Summary:
11:                    This is the clock.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.85
17:                        Device            :  dsPIC33EP128MC504
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.35
20:                        MPLAB             :  MPLAB X v5.05
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdint.h>
46:                #include "xc.h"
47:                #include "clock.h"
48:                
49:                void CLOCK_Initialize(void)
50:                {
00193C  FA0000     LNK #0x0
51:                    // FRCDIV FRC/2; PLLPRE 4; DOZE 1:8; PLLPOST 1:2; DOZEN disabled; ROI disabled; 
52:                    CLKDIV = 0x3102;
00193E  231020     MOV #0x3102, W0
001940  883A20     MOV W0, CLKDIV
53:                    // TUN Center frequency; 
54:                    OSCTUN = 0x00;
001942  EF2748     CLR OSCTUN
55:                    // ROON disabled; ROSEL disabled; RODIV Base clock value; ROSSLP disabled; 
56:                    REFOCON = 0x00;
001944  EF274E     CLR REFOCON
57:                    // PLLDIV 129; 
58:                    PLLFBD = 0x81;
001946  200810     MOV #0x81, W0
001948  883A30     MOV W0, PLLFBD
59:                    // AD1MD enabled; PWMMD enabled; T3MD enabled; T4MD enabled; T1MD enabled; U2MD enabled; T2MD enabled; U1MD enabled; QEI1MD enabled; SPI2MD enabled; SPI1MD enabled; C1MD enabled; T5MD enabled; I2C1MD enabled; 
60:                    PMD1 = 0x00;
00194A  EF2760     CLR PMD1
61:                    // IC4MD enabled; IC3MD enabled; OC1MD enabled; IC2MD enabled; OC2MD enabled; IC1MD enabled; OC3MD enabled; OC4MD enabled; 
62:                    PMD2 = 0x00;
00194C  EF2762     CLR PMD2
63:                    // CMPMD enabled; CRCMD enabled; I2C2MD enabled; 
64:                    PMD3 = 0x00;
00194E  EF2764     CLR PMD3
65:                    // CTMUMD enabled; REFOMD enabled; 
66:                    PMD4 = 0x00;
001950  EF2766     CLR PMD4
67:                    // PWM2MD enabled; PWM1MD enabled; PWM3MD enabled; 
68:                    PMD6 = 0x00;
001952  EF276A     CLR PMD6
69:                    // PTGMD enabled; DMA0MD enabled; 
70:                    PMD7 = 0x00;
001954  EF276C     CLR PMD7
71:                    // CF no clock failure; NOSC FRCPLL; CLKLOCK unlocked; OSWEN Switch is Complete; 
72:                    __builtin_write_OSCCONH((uint8_t) ((0x100 >> _OSCCON_NOSC_POSITION) & 0x00FF));
001956  200012     MOV #0x1, W2
001958  200780     MOV #0x78, W0
00195A  2009A1     MOV #0x9A, W1
00195C  207433     MOV #0x743, W3
00195E  784980     MOV.B W0, [W3]
001960  784981     MOV.B W1, [W3]
001962  784982     MOV.B W2, [W3]
73:                    __builtin_write_OSCCONL((uint8_t) ((0x100 | _OSCCON_OSWEN_MASK) & 0xFF));
001964  200012     MOV #0x1, W2
001966  200460     MOV #0x46, W0
001968  200571     MOV #0x57, W1
00196A  207423     MOV #0x742, W3
00196C  784980     MOV.B W0, [W3]
00196E  784981     MOV.B W1, [W3]
001970  784982     MOV.B W2, [W3]
74:                    // Wait for Clock switch to occur
75:                    while (OSCCONbits.OSWEN != 0);
001972  000000     NOP
001974  803A10     MOV OSCCON, W0
001976  600061     AND W0, #0x1, W0
001978  E00000     CP0 W0
00197A  3AFFFC     BRA NZ, .L2
76:                    while (OSCCONbits.LOCK != 1);
00197C  000000     NOP
00197E  803A11     MOV OSCCON, W1
001980  200200     MOV #0x20, W0
001982  608000     AND W1, W0, W0
001984  E00000     CP0 W0
001986  32FFFB     BRA Z, .L3
77:                }
001988  FA8000     ULNK
00198A  060000     RETURN
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/main.c  ----------------------------------
1:                 /**
2:                   Generated main.c file from MPLAB Code Configurator
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     main.c
9:                 
10:                  @Summary
11:                    This is the generated main.c using PIC24 / dsPIC33 / PIC32MM MCUs.
12:                
13:                  @Description
14:                    This source file provides main entry point for system intialization and application code development.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.75.1
17:                        Device            :  dsPIC33EP128MC504
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.35
20:                        MPLAB 	          :  MPLAB X v5.05
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                #include "mcc_generated_files/system.h"
49:                #include "mcc_generated_files/mcc.h"
50:                 
51:                #include "process.h"
52:                #include <libpic30.h>
53:                #include "sh1106.h"
54:                #include "qei.h"
55:                #include "motor.h"
56:                #include "adc.h"
57:                #include "servo.h"
58:                
59:                
60:                void initialize(void);
61:                
62:                void initialize(void) {
0017B8  FA0000     LNK #0x0
63:                
64:                    SYSTEM_Initialize();
0017BA  07011A     RCALL SYSTEM_Initialize
65:                    
66:                    qei_Init();
0017BC  0700E7     RCALL qei_Init
67:                    qei_On();
0017BE  0700FA     RCALL qei_On
68:                    __delay_ms(150);
0017C0  20E480     MOV #0xE48, W0
0017C2  200451     MOV #0x45, W1
0017C4  07015E     RCALL ___delay32, .Letext0, .LFE58
69:                    i2c_Init();
0017C6  07F7F8     RCALL i2c_Init
70:                    sh1106_Init();
0017C8  07F854     RCALL sh1106_Init
71:                    PWM_ModuleEnable();
0017CA  07FFDB     RCALL .Letext0, .LFE10, _PWM_ModuleEnable, .Ltext0, .LFB5
72:                    servo_Init();
0017CC  07FC23     RCALL servo_Init
73:                    ADC_Init();
0017CE  07FF01     RCALL ADC_Init
74:                    ADC_On();
0017D0  07FF0F     RCALL ADC_On
75:                }
0017D2  FA8000     ULNK
0017D4  060000     RETURN
76:                
77:                //set startup positions and values
78:                void configure(void){
0017D6  FA0000     LNK #0x0
79:                    probe1_SetStartPos();
0017D8  07FC01     RCALL probe1_SetStartPos
80:                    
81:                }
0017DA  FA8000     ULNK
0017DC  060000     RETURN
82:                
83:                /*
84:                                         Main application
85:                 */
86:                int main(void)
87:                {
0017DE  FA0004     LNK #0x4
88:                    static uint8_t loopcnt = 0;
89:                    // initialize the device
90:                    initialize();  
0017E0  07FFEB     RCALL initialize
91:                    // set startup positions and values
92:                    configure();
0017E2  07FFF9     RCALL configure
93:                    
94:                    PWM_GENERATOR genNum = PWM_GENERATOR_1;
0017E4  200010     MOV #0x1, W0
0017E6  780F00     MOV W0, [W14]
95:                    PWM_DutyCycleSet(genNum, 0x500);
0017E8  205001     MOV #0x500, W1
0017EA  78001E     MOV [W14], W0
0017EC  07FFCE     RCALL _PWM_DutyCycleSet, .LFE5, .LFB30
0017EE  370001     BRA .L14
96:                    
97:                    while (1)
98:                    {             
99:                        if(IFS0bits.T2IF)
0017F2  804001     MOV IFS0, W1
0017F4  200800     MOV #0x80, W0
0017F6  608000     AND W1, W0, W0
0017F8  E00000     CP0 W0
0017FA  32000A     BRA Z, .L12
100:                       {
101:                           loopcnt++;       
0017FC  BFD048     MOV.B loopcnt, WREG
0017FE  E84000     INC.B W0, W0
001800  B7F048     MOV.B WREG, loopcnt
102:                           IFS0bits.T2IF = false;
001802  A9E800     BCLR IFS0, #7
103:                           loop100us();
001804  07FCF4     RCALL loop100us
104:                           
105:                           if(loopcnt == 10){
001806  BFD048     MOV.B loopcnt, WREG
001808  504FEA     SUB.B W0, #0xA, [W15]
00180A  3A0002     BRA NZ, .L12
106:                               loopcnt = 0;
00180C  EF7048     CLR.B loopcnt
107:                               loop1ms();
00180E  07FD03     RCALL loop1ms
108:                           }            
109:                       } 
110:                       //processStrainValue(filter(readADC()));
111:                       if (ADC_IsCH1Valid()) {
001810  07FEFA     RCALL ADC_IsCH1Valid
001812  E00400     CP0.B W0
001814  32FFED     BRA Z, .L15
112:                           int16_t adctemp = ADC_GetCH1() >> 6;
001816  07FEFB     RCALL ADC_GetCH1
001818  DE8046     ASR W0, #6, W0
00181A  980710     MOV W0, [W14+2]
113:               
114:                           //adctemp = servo_1LPFilter(adctemp);
115:                           test_SetADCValue(adctemp);
00181C  90001E     MOV [W14+2], W0
00181E  07FDBB     RCALL test_SetADCValue
116:               
117:                           servo_1Run(adctemp);
001820  90001E     MOV [W14+2], W0
001822  07FC29     RCALL servo_1Run
118:                       //testValues(filter(adctemp), adctemp);
119:                       
120:                       }                 
121:                       // Add your application code                     
122:                   }
0017F0  000000     NOP
001824  37FFE6     BRA .L14
123:                   return 1; 
124:               }
125:                
126:               /**
127:                End of File
128:               */
129:               
---  /home/mjacobs/Programming/MPLABXProjects/L6203dualmotor.X/adc.c  -----------------------------------
1:                 
2:                 
3:                 
4:                 #include "mcc_generated_files/mcc.h"
5:                 #include <xc.h>
6:                 #include "adc.h"
7:                 #include <stdint.h>
8:                 #include <stdbool.h>
9:                 
10:                
11:                static ADC_CH ch0;
12:                static ADC_CH ch1;
13:                
14:                void ADC_Init(void){        
0015D2  FA0000     LNK #0x0
15:                    // bits 8-9  FORM<1:0> 
16:                    AD1CON1 = 0x038C;
0015D4  2038C0     MOV #0x38C, W0
0015D6  881900     MOV W0, AD1CON1
17:                    
18:                    AD1CON2 = 0x0104;
0015D8  201040     MOV #0x104, W0
0015DA  881910     MOV W0, AD1CON2
19:                    
20:                    AD1CON3 = 0x0010;
0015DC  200100     MOV #0x10, W0
0015DE  881920     MOV W0, AD1CON3
21:                    
22:                    AD1CON4 = 0x0000;
0015E0  EF2332     CLR AD1CON4
23:                    
24:                    AD1CHS0 = 0x0101;
0015E2  201010     MOV #0x101, W0
0015E4  881940     MOV W0, AD1CHS0
25:                    
26:                    AD1CHS123 = 0x0000;
0015E6  EF2326     CLR AD1CHS123
27:                    
28:                    AD1CSSH = 0x0000;
0015E8  EF232E     CLR AD1CSSH
29:                    
30:                    AD1CSSL = 0x0000;       
0015EA  EF2330     CLR AD1CSSL
31:                    
32:                }
0015EC  FA8000     ULNK
0015EE  060000     RETURN
33:                
34:                void ADC_On(void){
0015F0  FA0000     LNK #0x0
35:                     // clear interrupt flag
36:                    IFS0bits.AD1IF  = 0;
0015F2  A9A801     BCLR 0x801, #5
37:                    // enable adc interrupt
38:                    IEC0bits.AD1IE = 1;
0015F4  A8A821     BSET 0x821, #5
39:                    
40:                    AD1CON1bits.ADON = 1;
0015F6  A8E321     BSET 0x321, #7
41:                }
0015F8  FA8000     ULNK
0015FA  060000     RETURN
42:                void ADC_Off(void){
0015FC  FA0000     LNK #0x0
43:                    AD1CON1bits.ADON = 0;
0015FE  A9E321     BCLR 0x321, #7
44:                    
45:                    // disable adc interrupt
46:                    IEC0bits.AD1IE = 0;
001600  A9A821     BCLR 0x821, #5
47:                }
001602  FA8000     ULNK
001604  060000     RETURN
48:                
49:                void __attribute__ ( ( interrupt, no_auto_psv ) ) _AD1Interrupt(void){
00042E  F80036     PUSH RCOUNT
000430  BE9F80     MOV.D W0, [W15++]
000432  BE9F82     MOV.D W2, [W15++]
000434  BE9F84     MOV.D W4, [W15++]
000436  BE9F86     MOV.D W6, [W15++]
000438  FA0000     LNK #0x0
50:                
51:                    IFS0bits.AD1IF = 0;
00043A  A9A801     BCLR 0x801, #5
52:                    
53:                    // use if adc data right aligned
54:                    //ch0.value = ((int16_t)ADC1BUF0 + (int16_t)ADC1BUF2) / 2;
55:                    // use if adc data left aligned
56:                    ch0.value = (((int16_t)ADC1BUF0 / 2) + ((int16_t)ADC1BUF2 / 2));
00043C  801800     MOV ADC1BUF0, W0
00043E  DE00CF     LSR W0, #15, W1
000440  408000     ADD W1, W0, W0
000442  D18000     ASR W0, W0
000444  780080     MOV W0, W1
000446  801820     MOV ADC1BUF2, W0
000448  DE014F     LSR W0, #15, W2
00044A  410000     ADD W2, W0, W0
00044C  D18000     ASR W0, W0
00044E  408000     ADD W1, W0, W0
000450  8880D0     MOV W0, ch0
57:                    ch0.value = LPFilterCH0(ch0.value);
000452  8080D0     MOV ch0, W0
000454  0708E1     RCALL LPFilterCH0
000456  8880D0     MOV W0, ch0
58:                    ch0.validf = true;
000458  B3C010     MOV.B #0x1, W0
00045A  B7F01C     MOV.B WREG, 0x101C
59:                    
60:                    // use if adc data right aligned
61:                    //ch1.value = ((int16_t)ADC1BUF1 + (int16_t)ADC1BUF3) / 2;
62:                    // use if adc data left aligned
63:                    ch1.value = (((int16_t)ADC1BUF1 / 2) + ((int16_t)ADC1BUF3 / 2));
00045C  801810     MOV ADC1BUF1, W0
00045E  DE00CF     LSR W0, #15, W1
000460  408000     ADD W1, W0, W0
000462  D18000     ASR W0, W0
000464  780080     MOV W0, W1
000466  801830     MOV ADC1BUF3, W0
000468  DE014F     LSR W0, #15, W2
00046A  410000     ADD W2, W0, W0
00046C  D18000     ASR W0, W0
00046E  408000     ADD W1, W0, W0
000470  8880F0     MOV W0, ch1
64:                    ch1.value = LPFilterCH1(ch1.value);
000472  8080F0     MOV ch1, W0
000474  0708FF     RCALL LPFilterCH1
000476  8880F0     MOV W0, ch1
65:                    ch1.validf = true;    
000478  B3C010     MOV.B #0x1, W0
00047A  B7F020     MOV.B WREG, 0x1020
66:                }
00047C  FA8000     ULNK
00047E  BE034F     MOV.D [--W15], W6
000480  BE024F     MOV.D [--W15], W4
000482  BE014F     MOV.D [--W15], W2
000484  BE004F     MOV.D [--W15], W0
000486  F90036     POP RCOUNT
000488  064000     RETFIE
67:                
68:                bool ADC_IsCH1Valid(void){
001606  FA0000     LNK #0x0
69:                    
70:                    return ch1.validf;       
001608  BFD020     MOV.B 0x1020, WREG
71:                }
00160A  FA8000     ULNK
00160C  060000     RETURN
72:                
73:                int16_t ADC_GetCH1(void){
00160E  FA0000     LNK #0x0
74:                    
75:                    ch1.validf = false;
001610  EF7020     CLR.B 0x1020
76:                    return ch1.value;    
001612  8080F0     MOV ch1, W0
77:                }
001614  FA8000     ULNK
001616  060000     RETURN
78:                
79:                int16_t LPFilterCH0(int16_t input){
001618  FA0002     LNK #0x2
00161A  780F00     MOV W0, [W14]
80:                    static int16_t data[8]= {0, 0, 0, 0, 0, 0, 0, 0};
81:                    static int index = 0;
82:                    static int32_t value = 0; 
83:                    
84:                    value = value - ((int32_t)data[index] - (int32_t)input);
00161C  78001E     MOV [W14], W0
00161E  B90261     MUL.SU W0, #0x1, W4
001620  808140     MOV index, W0
001622  400080     ADD W0, W0, W1
001624  210D00     MOV #0x10D0, W0
001626  408000     ADD W1, W0, W0
001628  780010     MOV [W0], W0
00162A  DE80CF     ASR W0, #15, W1
00162C  520200     SUB W4, W0, W4
00162E  5A8281     SUBB W5, W1, W5
001630  808150     MOV value, W0
001632  808161     MOV 0x102C, W1
001634  400004     ADD W0, W4, W0
001636  488085     ADDC W1, W5, W1
001638  888150     MOV W0, value
00163A  888161     MOV W1, 0x102C
85:                    data[index] = input;
00163C  808140     MOV index, W0
00163E  400080     ADD W0, W0, W1
001640  210D00     MOV #0x10D0, W0
001642  408000     ADD W1, W0, W0
001644  78081E     MOV [W14], [W0]
86:                    index = ((index == 7) ? 0: index+1);
001646  808140     MOV index, W0
001648  500FE7     SUB W0, #0x7, [W15]
00164A  320003     BRA Z, .L8
00164C  808140     MOV index, W0
00164E  E80000     INC W0, W0
001650  370001     BRA .L9
001652  EB0000     CLR W0
001654  888140     MOV W0, index
87:                    
88:                    return (value / 8);
001656  808150     MOV value, W0
001658  808161     MOV 0x102C, W1
00165A  500FE0     SUB W0, #0x0, [W15]
00165C  588FE0     SUBB W1, #0x0, [W15]
00165E  3D0002     BRA GE, .L10
001660  400067     ADD W0, #0x7, W0
001662  4880E0     ADDC W1, #0x0, W1
001664  DD0A4D     SL W1, #13, W4
001666  DE0143     LSR W0, #3, W2
001668  720102     IOR W4, W2, W2
00166A  DE89C3     ASR W1, #3, W3
00166C  BE0002     MOV.D W2, W0
00166E  780000     MOV W0, W0
89:                    
90:                }
001670  FA8000     ULNK
001672  060000     RETURN
91:                
92:                int16_t LPFilterCH1(int16_t input){
001674  FA0002     LNK #0x2
001676  780F00     MOV W0, [W14]
93:                    static int16_t data[8]= {0, 0, 0, 0, 0, 0, 0, 0};
94:                    static int index = 0;
95:                    static int32_t value = 0; 
96:                    
97:                    value = value - ((int32_t)data[index] - (int32_t)input);
001678  78001E     MOV [W14], W0
00167A  B90261     MUL.SU W0, #0x1, W4
00167C  808110     MOV index, W0
00167E  400080     ADD W0, W0, W1
001680  210C00     MOV #0x10C0, W0
001682  408000     ADD W1, W0, W0
001684  780010     MOV [W0], W0
001686  DE80CF     ASR W0, #15, W1
001688  520200     SUB W4, W0, W4
00168A  5A8281     SUBB W5, W1, W5
00168C  808120     MOV value, W0
00168E  808131     MOV 0x1026, W1
001690  400004     ADD W0, W4, W0
001692  488085     ADDC W1, W5, W1
001694  888120     MOV W0, value
001696  888131     MOV W1, 0x1026
98:                    data[index] = input;
001698  808110     MOV index, W0
00169A  400080     ADD W0, W0, W1
00169C  210C00     MOV #0x10C0, W0
00169E  408000     ADD W1, W0, W0
0016A0  78081E     MOV [W14], [W0]
99:                    index = ((index == 7) ? 0: index+1);
0016A2  808110     MOV index, W0
0016A4  500FE7     SUB W0, #0x7, [W15]
0016A6  320003     BRA Z, .L12
0016A8  808110     MOV index, W0
0016AA  E80000     INC W0, W0
0016AC  370001     BRA .L13
0016AE  EB0000     CLR W0
0016B0  888110     MOV W0, index
100:                   
101:                   return (value / 8);
0016B2  808120     MOV value, W0
0016B4  808131     MOV 0x1026, W1
0016B6  500FE0     SUB W0, #0x0, [W15]
0016B8  588FE0     SUBB W1, #0x0, [W15]
0016BA  3D0002     BRA GE, .L14
0016BC  400067     ADD W0, #0x7, W0
0016BE  4880E0     ADDC W1, #0x0, W1
0016C0  DD0A4D     SL W1, #13, W4
0016C2  DE0143     LSR W0, #3, W2
0016C4  720102     IOR W4, W2, W2
0016C6  DE89C3     ASR W1, #3, W3
0016C8  BE0002     MOV.D W2, W0
0016CA  780000     MOV W0, W0
102:                   
103:               }
0016CC  FA8000     ULNK
0016CE  060000     RETURN
